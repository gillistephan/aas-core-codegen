"""Provide common functions shared among different Go code generation modules."""
from typing import cast
from aas_core_codegen import intermediate
from aas_core_codegen.common import Identifier, Stripped, assert_never
from aas_core_codegen.golang import naming as golang_naming

import textwrap


WARNING = Stripped(
    textwrap.dedent("// Code generated by aas-core-codegen. DO NOT EDIT.")
)

PRIMITIVE_TYPE_MAP = {
    intermediate.PrimitiveType.BOOL: Stripped("bool"),
    intermediate.PrimitiveType.INT: Stripped("int"),
    intermediate.PrimitiveType.FLOAT: Stripped("float"),
    intermediate.PrimitiveType.STR: Stripped("string"),
    intermediate.PrimitiveType.BYTEARRAY: Stripped("[]byte"),
}


def generate_type(type_annotation: intermediate.TypeAnnotationUnion) -> Stripped:
    if isinstance(type_annotation, intermediate.PrimitiveTypeAnnotation):
        return PRIMITIVE_TYPE_MAP[type_annotation.a_type]

    elif isinstance(type_annotation, intermediate.OurTypeAnnotation):
        symbol = type_annotation.symbol

        if isinstance(symbol, intermediate.Enumeration):
            return Stripped(f"*{golang_naming.enum_name(type_annotation.symbol.name)}")

        elif isinstance(symbol, intermediate.ConstrainedPrimitive):
            return PRIMITIVE_TYPE_MAP[symbol.constrainee]

        elif isinstance(symbol, intermediate.Class):
            return Stripped(f"*{golang_naming.class_name(symbol.name)}")

    elif isinstance(type_annotation, intermediate.ListTypeAnnotation):
        item_type = generate_type(
            type_annotation=type_annotation.items,
        )
        # NOTE Super ugly hack, to replace the pointer here (have to think about)
        # if we need pointer slices, as slices are anyway passed as reference to functions
        # have to think a litte more about the use cases
        # e.g. see: https://medium.com/swlh/golang-tips-why-pointers-to-slices-are-useful-and-how-ignoring-them-can-lead-to-tricky-bugs-cac90f72e77b
        replaced = item_type.replace("*", "")
        return Stripped(f"[]{replaced}")

    elif isinstance(type_annotation, intermediate.RefTypeAnnotation):
        return Stripped(f"Todo")

    # implement this here, although Go doesn't have optionals
    # (instantiation always with zero value) to avoid fall through
    elif isinstance(type_annotation, intermediate.OptionalTypeAnnotation):
        value = generate_type(type_annotation=type_annotation.value)
        return Stripped(f"{value}")

    else:
        assert_never(type_annotation)
