// Code generated by aas-core-codegen. DO NOT EDIT.

package aascore

import (
	"fmt"
	"io"
	"reflect"

	json "github.com/json-iterator/go"
)

const (
	NonNilPointerError = "v must be a pointer and non nil"
)

// AasCoreMarshaler is the interface implemented by all types of the meta-model
// that can marshal themselves into a valid JSON.
type AasCoreMarshaler interface {
	marshalJSON(stream *json.Stream)
}

// AasCoreUnmarshaler is the interface implemented by all types of the meta-model
// that can unmarshal a JSON description of themselves.
type AasCoreUnmarshaler interface {
	unmarshalJSON(iter *json.Iterator)
}

// Encoder writes JSON values to an output stream.
type Encoder struct {
	stream *json.Stream
}

// Decoder reads and decodes JSON values from an input stream.
type Decoder struct {
	iter *json.Iterator
}

// isNonNilPointer checks, if a given value v is a pointer or not nil
func isNonNilPointer(v interface{}) bool {
	rv := reflect.ValueOf(v)
	if rv.Kind() != reflect.Ptr || rv.IsNil() {
		return false
	}
	return true
}

// Unmarshal parses the JSON-encoded data and stores
// the result in the value pointed by v. If v is nil or not a pointer
// Unmarshal returns an error. If v implements the AasCoreUnmarshaler interface
// of the AAS-Meta-Model, data will be decoded according to the specifications of
// the meta-model. If not, Unmarshal will decode the data in complience with
// the standard library. It can be used as a drop-in replacement
// of the encoding/json standard library.
func Unmarshal(data []byte, v interface{}) error {
	if isNonNilPointer(v) {
		return fmt.Errorf(NonNilPointerError)
	}

	if u, ok := v.(AasCoreUnmarshaler); !ok {
		return json.Unmarshal(data, data)
	} else {
		iter := json.ParseBytes(json.ConfigDefault, data)
		dec := &Decoder{iter}
		err := dec.Decode(u)
		return err
	}
}

// Marshal traverses the value v recursively. If v implements the AasCoreMarshaler
// interface and is not a nil pointer, Marshal calls the marshalJSON method to encode
// v according to the specifications of the AAS-Meta-Model. If v does not implement the
// AasCoreMarshaler interface, Marshal will decode the data in complience with standard
// library. It can be used as a drop-in replacement of the encoding/json standard library.
func Marshal(v interface{}) ([]byte, error) {
	if m, ok := v.(AasCoreMarshaler); !ok {
		return json.Marshal(v)
	} else {
		stream := json.ConfigDefault.BorrowStream(nil)
		enc := &Encoder{stream}
		err := enc.Encode(m)
		if err != nil {
			return nil, err
		}
		bytes := enc.stream.Buffer()
		return bytes, nil
	}
}

// NewDecoder returns a new Decoder that reads from r.
// Bs is the internal buffer size set in the NewDecoder.
func NewDecoder(bs int, r io.Reader) *Decoder {
	iter := json.Parse(json.ConfigCompatibleWithStandardLibrary, r, bs)
	return &Decoder{iter}
}

// NewEcoder returns a new Encoder that writes to w.
// Bs is the internal buffer size set in the NewEncoder.
func NewEncoder(bs int, w io.Writer) *Encoder {
	stream := json.NewStream(json.ConfigCompatibleWithStandardLibrary, w, bs)
	return &Encoder{stream}
}

// Decode reads the next encoded value from its input and
// writes it in the value pointed to by v. If v implements
// the AasCoreUnmarshaler interface, v will be decoded according
// to the specifications of the AAS-Meta-Model. If not,
// Decode will decode the data in complience with the standard library.
// It can be used as a drop-in replacement of the encoding/json standard library.
func (d *Decoder) Decode(v interface{}) error {
	if isNonNilPointer(v) {
		return fmt.Errorf(NonNilPointerError)
	}
	if u, ok := v.(AasCoreUnmarshaler); !ok {
		d.iter.ReadVal(v)
	} else {
		u.unmarshalJSON(d.iter)
	}
	err := d.iter.Error
	if err == io.EOF {
		return nil
	}
	return d.iter.Error
}

// Encode writes the encoding of v to the input stream v.
// If v implements the AasCoreMarshaler interface and v is
// not a nil pointer, Encode calls the marshalJSON method recursively
// and encodes the data according to the specifications of the AAS-Meta-Model.
// If v does not implement AasCoreMarshaler interface, Encode will encode the
// data in complience with the standard library. It can be used as a drop-in
// replacement of the encoding/json standard library.
func (e *Encoder) Encode(v interface{}) error {
	if m, ok := v.(AasCoreMarshaler); !ok {
		e.stream.WriteVal(v)
	} else {
		m.marshalJSON(e.stream)
	}
	e.stream.WriteRaw("\n")
	e.stream.Flush()
	return e.stream.Error
}

// unmarshalJSON implements the Unmarshaler interface for Extension
func (c *Extension) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"name": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "semanticID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "name":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Name = iter.ReadString()
			isThere["name"] = true
		case "valueType":
			var myenum DataTypeDef
			myenum.unmarshalJSON(iter)
			c.ValueType = &myenum
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Value = &val
		case "refersTo":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.RefersTo = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object extension", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Extension
func (c *Extension) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	if c.SemanticId != nil {
		stream.WriteObjectField("semanticID")
		c.SemanticId.marshalJSON(stream)
	}

	stream.WriteObjectField("name")
	stream.WriteString(c.Name)
	stream.WriteMore()

	if c.ValueType != nil {
		stream.WriteObjectField("valueType")
		c.ValueType.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Value != nil {
		stream.WriteObjectField("value")
		stream.WriteString(*c.Value)
		stream.WriteMore()
	}

	if c.RefersTo != nil {
		stream.WriteObjectField("refersTo")
		c.RefersTo.marshalJSON(stream)
	}

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for ReferableData
func (d *ReferableData) unmarshalJSON(iter *json.Iterator) {
	c := struct {
		// Shared Properties
		Extensions  []*Extension
		IdShort     *string
		DisplayName *LangStringSet
		Category    *string
		Description *LangStringSet
		// Used in AnnotatedRelationshipElement + AssetAdministrationShell + BasicEvent + Blob + Capability + ConceptDescription + Entity + File + MultiLanguageProperty + Operation + Property + Range + ReferenceElement + Submodel + SubmodelElementList + SubmodelElementStruct + View
		DataSpecifications []*ReferenceData
		// Used in AnnotatedRelationshipElement + BasicEvent + Blob + Capability + Entity + File + MultiLanguageProperty + Operation + Property + Range + ReferenceElement + Submodel + SubmodelElementList + SubmodelElementStruct
		Kind *ModelingKind
		// Used in AnnotatedRelationshipElement + BasicEvent + Blob + Capability + Entity + File + MultiLanguageProperty + Operation + Property + Range + ReferenceElement + Submodel + SubmodelElementList + SubmodelElementStruct + View
		SemanticId *ReferenceData
		// Used in AnnotatedRelationshipElement + BasicEvent + Blob + Capability + Entity + File + MultiLanguageProperty + Operation + Property + Range + ReferenceElement + Submodel + SubmodelElementList + SubmodelElementStruct
		Qualifiers []*ConstraintData
		// Used in AnnotatedRelationshipElement
		First *ReferenceData
		// Used in AnnotatedRelationshipElement
		Second *ReferenceData
		// Used in AnnotatedRelationshipElement
		Annotation []*DataElementData
		// Used in AssetAdministrationShell + ConceptDescription + Submodel
		Id *string
		// Used in AssetAdministrationShell + ConceptDescription + Submodel
		Administration *AdministrativeInformation
		// Used in AssetAdministrationShell
		DerivedFrom *AssetAdministrationShell
		// Used in AssetAdministrationShell
		AssetInformation *AssetInformation
		// Used in AssetAdministrationShell
		Submodels []*Submodel
		// Used in BasicEvent
		Observed *Referable
		// Used in Blob + File
		MimeType *string
		// Used in Blob
		Content *[]byte
		// Used in ConceptDescription
		IsCaseOf []*ReferenceData
		// Used in Entity
		EntityType *EntityType
		// Used in Entity
		Statements []*SubmodelElementData
		// Used in Entity
		GlobalAssetId *ReferenceData
		// Used in Entity
		SpecificAssetId *IdentifierKeyValuePair
		// Used in File + Property
		Value *string
		// Used in MultiLanguageProperty
		Translatable *LangStringSet
		// Used in MultiLanguageProperty + Property
		ValueId *ReferenceData
		// Used in Operation
		InputVariables []*OperationVariable
		// Used in Operation
		OutputVariables []*OperationVariable
		// Used in Operation
		InoutputVariables []*OperationVariable
		// Used in Property + Range
		ValueType *DataTypeDef
		// Used in Range
		Min *string
		// Used in Range
		Max *string
		// Used in ReferenceElement
		Reference *ReferenceData
		// Used in Submodel
		SubmodelElements []*SubmodelElementData
		// Used in SubmodelElementList
		SubmodelElementTypeValues *SubmodelElements
		// Used in SubmodelElementList + SubmodelElementStruct
		Values []*SubmodelElementData
		// Used in SubmodelElementList
		SemanticIdValues *ReferenceData
		// Used in SubmodelElementList
		ValueTypeValues *DataTypeDef
		// Used in View
		ContainedElements []*Referable
	}{}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "extensions": // loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, myobj)
			}
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.IdShort = &val
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Category = &val
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, myobj)
			}
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ConstraintData{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, myobj)
			}
		case "first":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.First = myobj
		case "second":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.Second = myobj
		case "annotation":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &DataElementData{}
				myobj.unmarshalJSON(iter)
				c.Annotation = append(c.Annotation, myobj)
			}
		case "id":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Id = &val
		case "administration":
			myobj := &AdministrativeInformation{}
			myobj.unmarshalJSON(iter)
			c.Administration = myobj
		case "derivedFrom":
		case "assetInformation":
			myobj := &AssetInformation{}
			myobj.unmarshalJSON(iter)
			c.AssetInformation = myobj
		case "submodels":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
			}
		case "observed":
		case "mimeType":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.MimeType = &val
		case "content":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Content = &val
		case "isCaseOf":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.IsCaseOf = append(c.IsCaseOf, myobj)
			}
		case "entityType":
			var myenum EntityType
			myenum.unmarshalJSON(iter)
			c.EntityType = &myenum
		case "statements":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &SubmodelElementData{}
				myobj.unmarshalJSON(iter)
				c.Statements = append(c.Statements, myobj)
			}
		case "globalAssetID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.GlobalAssetId = myobj
		case "specificAssetID":
			myobj := &IdentifierKeyValuePair{}
			myobj.unmarshalJSON(iter)
			c.SpecificAssetId = myobj
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Value = &val
		case "translatable":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Translatable = myobj
		case "valueID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.ValueId = myobj
		case "inputVariables":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &OperationVariable{}
				myobj.unmarshalJSON(iter)
				c.InputVariables = append(c.InputVariables, myobj)
			}
		case "outputVariables":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &OperationVariable{}
				myobj.unmarshalJSON(iter)
				c.OutputVariables = append(c.OutputVariables, myobj)
			}
		case "inoutputVariables":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &OperationVariable{}
				myobj.unmarshalJSON(iter)
				c.InoutputVariables = append(c.InoutputVariables, myobj)
			}
		case "valueType":
			var myenum DataTypeDef
			myenum.unmarshalJSON(iter)
			c.ValueType = &myenum
		case "min":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Min = &val
		case "max":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Max = &val
		case "reference":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.Reference = myobj
		case "submodelElements":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &SubmodelElementData{}
				myobj.unmarshalJSON(iter)
				c.SubmodelElements = append(c.SubmodelElements, myobj)
			}
		case "submodelElementTypeValues":
			var myenum SubmodelElements
			myenum.unmarshalJSON(iter)
			c.SubmodelElementTypeValues = &myenum
		case "values":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &SubmodelElementData{}
				myobj.unmarshalJSON(iter)
				c.Values = append(c.Values, myobj)
			}
		case "semanticIDValues":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticIdValues = myobj
		case "valueTypeValues":
			var myenum DataTypeDef
			myenum.unmarshalJSON(iter)
			c.ValueTypeValues = &myenum
		case "containedElements":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
			}
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object", f))
		}

		// Check if element is of type AnnotatedRelationshipElement
		if c.DataSpecifications != nil && c.Kind != nil && c.SemanticId != nil && c.Qualifiers != nil && c.First != nil && c.Second != nil && c.Annotation != nil {
			// Construct AnnotatedRelationshipElement
			var obj *AnnotatedRelationshipElement
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Annotation = c.Annotation
			// Assign obj to ReferableData
			d.AnnotatedRelationshipElement = obj
		} else if // Check if element is of type AssetAdministrationShell
		c.DataSpecifications != nil && c.Id != nil && c.Administration != nil && c.DerivedFrom != nil && c.AssetInformation != nil && c.Submodels != nil {
			// Construct AssetAdministrationShell
			var obj *AssetAdministrationShell
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Administration = c.Administration
			obj.DerivedFrom = c.DerivedFrom
			obj.Submodels = c.Submodels
			// Assign obj to ReferableData
			d.AssetAdministrationShell = obj
		} else if // Check if element is of type BasicEvent
		c.DataSpecifications != nil && c.Kind != nil && c.SemanticId != nil && c.Qualifiers != nil && c.Observed != nil {
			// Construct BasicEvent
			var obj *BasicEvent
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			// Assign obj to ReferableData
			d.BasicEvent = obj
		} else if // Check if element is of type Blob
		c.DataSpecifications != nil && c.Kind != nil && c.SemanticId != nil && c.Qualifiers != nil && c.MimeType != nil && c.Content != nil {
			// Construct Blob
			var obj *Blob
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Content = c.Content
			// Assign obj to ReferableData
			d.Blob = obj
		} else if // Check if element is of type Capability
		c.DataSpecifications != nil && c.Kind != nil && c.SemanticId != nil && c.Qualifiers != nil {
			// Construct Capability
			var obj *Capability
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			// Assign obj to ReferableData
			d.Capability = obj
		} else if // Check if element is of type ConceptDescription
		c.DataSpecifications != nil && c.Id != nil && c.Administration != nil && c.IsCaseOf != nil {
			// Construct ConceptDescription
			var obj *ConceptDescription
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Administration = c.Administration
			obj.IsCaseOf = c.IsCaseOf
			// Assign obj to ReferableData
			d.ConceptDescription = obj
		} else if // Check if element is of type Entity
		c.DataSpecifications != nil && c.Kind != nil && c.SemanticId != nil && c.Qualifiers != nil && c.EntityType != nil && c.Statements != nil && c.GlobalAssetId != nil && c.SpecificAssetId != nil {
			// Construct Entity
			var obj *Entity
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Statements = c.Statements
			obj.GlobalAssetId = c.GlobalAssetId
			obj.SpecificAssetId = c.SpecificAssetId
			// Assign obj to ReferableData
			d.Entity = obj
		} else if // Check if element is of type File
		c.DataSpecifications != nil && c.Kind != nil && c.SemanticId != nil && c.Qualifiers != nil && c.MimeType != nil && c.Value != nil {
			// Construct File
			var obj *File
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Value = c.Value
			// Assign obj to ReferableData
			d.File = obj
		} else if // Check if element is of type MultiLanguageProperty
		c.DataSpecifications != nil && c.Kind != nil && c.SemanticId != nil && c.Qualifiers != nil && c.Translatable != nil && c.ValueId != nil {
			// Construct MultiLanguageProperty
			var obj *MultiLanguageProperty
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Translatable = c.Translatable
			obj.ValueId = c.ValueId
			// Assign obj to ReferableData
			d.MultiLanguageProperty = obj
		} else if // Check if element is of type Operation
		c.DataSpecifications != nil && c.Kind != nil && c.SemanticId != nil && c.Qualifiers != nil && c.InputVariables != nil && c.OutputVariables != nil && c.InoutputVariables != nil {
			// Construct Operation
			var obj *Operation
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.InputVariables = c.InputVariables
			obj.OutputVariables = c.OutputVariables
			obj.InoutputVariables = c.InoutputVariables
			// Assign obj to ReferableData
			d.Operation = obj
		} else if // Check if element is of type Property
		c.DataSpecifications != nil && c.Kind != nil && c.SemanticId != nil && c.Qualifiers != nil && c.ValueType != nil && c.Value != nil && c.ValueId != nil {
			// Construct Property
			var obj *Property
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Value = c.Value
			obj.ValueId = c.ValueId
			// Assign obj to ReferableData
			d.Property = obj
		} else if // Check if element is of type Range
		c.DataSpecifications != nil && c.Kind != nil && c.SemanticId != nil && c.Qualifiers != nil && c.ValueType != nil && c.Min != nil && c.Max != nil {
			// Construct Range
			var obj *Range
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Min = c.Min
			obj.Max = c.Max
			// Assign obj to ReferableData
			d.Range = obj
		} else if // Check if element is of type ReferenceElement
		c.DataSpecifications != nil && c.Kind != nil && c.SemanticId != nil && c.Qualifiers != nil && c.Reference != nil {
			// Construct ReferenceElement
			var obj *ReferenceElement
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Reference = c.Reference
			// Assign obj to ReferableData
			d.ReferenceElement = obj
		} else if // Check if element is of type Submodel
		c.DataSpecifications != nil && c.Kind != nil && c.SemanticId != nil && c.Qualifiers != nil && c.Id != nil && c.Administration != nil && c.SubmodelElements != nil {
			// Construct Submodel
			var obj *Submodel
			obj.DataSpecifications = c.DataSpecifications
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Administration = c.Administration
			obj.SubmodelElements = c.SubmodelElements
			// Assign obj to ReferableData
			d.Submodel = obj
		} else if // Check if element is of type SubmodelElementList
		c.DataSpecifications != nil && c.Kind != nil && c.SemanticId != nil && c.Qualifiers != nil && c.SubmodelElementTypeValues != nil && c.Values != nil && c.SemanticIdValues != nil && c.ValueTypeValues != nil {
			// Construct SubmodelElementList
			var obj *SubmodelElementList
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Values = c.Values
			obj.SemanticIdValues = c.SemanticIdValues
			obj.ValueTypeValues = c.ValueTypeValues
			// Assign obj to ReferableData
			d.SubmodelElementList = obj
		} else if // Check if element is of type SubmodelElementStruct
		c.DataSpecifications != nil && c.Kind != nil && c.SemanticId != nil && c.Qualifiers != nil && c.Values != nil {
			// Construct SubmodelElementStruct
			var obj *SubmodelElementStruct
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Values = c.Values
			// Assign obj to ReferableData
			d.SubmodelElementStruct = obj
		} else if // Check if element is of type View
		c.DataSpecifications != nil && c.SemanticId != nil && c.ContainedElements != nil {
			// Construct View
			var obj *View
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.SemanticId = c.SemanticId
			obj.ContainedElements = c.ContainedElements
			// Assign obj to ReferableData
			d.View = obj
		}
	}
}

// marshalJSON implements Marshaler interface for ReferableData
func (d *ReferableData) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
}

// unmarshalJSON implements the Unmarshaler interface for ModelingKind
func (e ModelingKind) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := ModelingKind_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for ModelingKind
func (e ModelingKind) marshalJSON(stream *json.Stream) {
	stream.WriteString(ModelingKind_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for AdministrativeInformation
func (c *AdministrativeInformation) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, myobj)
			}
			isThere["dataSpecifications"] = true
		case "version":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Version = &val
		case "revision":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Revision = &val
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object administrativeInformation", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for AdministrativeInformation
func (c *AdministrativeInformation) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	if c.Version != nil {
		stream.WriteObjectField("version")
		stream.WriteString(*c.Version)
		stream.WriteMore()
	}

	if c.Revision != nil {
		stream.WriteObjectField("revision")
		stream.WriteString(*c.Revision)
	}

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for ConstraintData
func (d *ConstraintData) unmarshalJSON(iter *json.Iterator) {
	c := struct {
		// Shared Properties
		// Used in Formula
		DependsOn []*ReferenceData
		// Used in Qualifier
		SemanticId *ReferenceData
		// Used in Qualifier
		Type *string
		// Used in Qualifier
		ValueType *DataTypeDef
		// Used in Qualifier
		Value *string
		// Used in Qualifier
		ValueId *ReferenceData
	}{}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dependsOn":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.DependsOn = append(c.DependsOn, myobj)
			}
		case "semanticID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "type":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Type = &val
		case "valueType":
			var myenum DataTypeDef
			myenum.unmarshalJSON(iter)
			c.ValueType = &myenum
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Value = &val
		case "valueID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.ValueId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object", f))
		}

		// Check if element is of type Formula
		if c.DependsOn != nil {
			// Construct Formula
			var obj *Formula
			obj.DependsOn = c.DependsOn
			// Assign obj to ConstraintData
			d.Formula = obj
		} else if // Check if element is of type Qualifier
		c.SemanticId != nil && c.Type != nil && c.ValueType != nil && c.Value != nil && c.ValueId != nil {
			// Construct Qualifier
			var obj *Qualifier
			obj.SemanticId = c.SemanticId
			obj.Value = c.Value
			obj.ValueId = c.ValueId
			// Assign obj to ConstraintData
			d.Qualifier = obj
		}
	}
}

// marshalJSON implements Marshaler interface for ConstraintData
func (d *ConstraintData) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
}

// unmarshalJSON implements the Unmarshaler interface for Qualifier
func (c *Qualifier) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"type":      false,
		"valueType": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "semanticID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "type":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Type = iter.ReadString()
			isThere["type"] = true
		case "valueType":
			var myenum DataTypeDef
			myenum.unmarshalJSON(iter)
			c.ValueType = myenum
			isThere["valueType"] = true
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Value = &val
		case "valueID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.ValueId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object qualifier", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Qualifier
func (c *Qualifier) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	if c.SemanticId != nil {
		stream.WriteObjectField("semanticID")
		c.SemanticId.marshalJSON(stream)
	}

	stream.WriteObjectField("type")
	stream.WriteString(c.Type)
	stream.WriteMore()

	stream.WriteObjectField("valueType")
	c.ValueType.marshalJSON(stream)
	stream.WriteMore()

	if c.Value != nil {
		stream.WriteObjectField("value")
		stream.WriteString(*c.Value)
		stream.WriteMore()
	}

	if c.ValueId != nil {
		stream.WriteObjectField("valueID")
		c.ValueId.marshalJSON(stream)
	}

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Formula
func (c *Formula) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dependsOn": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dependsOn":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.DependsOn = append(c.DependsOn, myobj)
			}
			isThere["dependsOn"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object formula", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Formula
func (c *Formula) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dependsOn")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DependsOn {
		k.marshalJSON(stream)
		if i < len(c.DependsOn)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for AssetAdministrationShell
func (c *AssetAdministrationShell) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"id":                 false,
		"assetInformation":   false,
		"submodels":          false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.IdShort = &val
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Category = &val
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "id":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Id = iter.ReadString()
			isThere["id"] = true
		case "administration":
			myobj := &AdministrativeInformation{}
			myobj.unmarshalJSON(iter)
			c.Administration = myobj
		case "derivedFrom":
		case "assetInformation":
			myobj := &AssetInformation{}
			myobj.unmarshalJSON(iter)
			isThere["assetInformation"] = true
			c.AssetInformation = myobj
		case "submodels":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
			}
			isThere["submodels"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object assetAdministrationShell", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for AssetAdministrationShell
func (c *AssetAdministrationShell) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	if c.IdShort != nil {
		stream.WriteObjectField("idShort")
		stream.WriteString(*c.IdShort)
		stream.WriteMore()
	}

	if c.DisplayName != nil {
		stream.WriteObjectField("displayName")
		c.DisplayName.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Category != nil {
		stream.WriteObjectField("category")
		stream.WriteString(*c.Category)
		stream.WriteMore()
	}

	if c.Description != nil {
		stream.WriteObjectField("description")
		c.Description.marshalJSON(stream)
		stream.WriteMore()
	}

	stream.WriteObjectField("id")
	stream.WriteString(c.Id)
	stream.WriteMore()

	if c.Administration != nil {
		stream.WriteObjectField("administration")
		c.Administration.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.DerivedFrom != nil {
		stream.WriteObjectField("derivedFrom")
		stream.WriteMore()
	}

	stream.WriteObjectField("assetInformation")
	c.AssetInformation.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("submodels")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Submodels {
		k.marshalJSON(stream)
		if i < len(c.Submodels)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for AssetInformation
func (c *AssetInformation) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"assetKind": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "assetKind":
			var myenum AssetKind
			myenum.unmarshalJSON(iter)
			c.AssetKind = myenum
			isThere["assetKind"] = true
		case "globalAssetID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.GlobalAssetId = myobj
		case "specificAssetID":
			myobj := &IdentifierKeyValuePair{}
			myobj.unmarshalJSON(iter)
			c.SpecificAssetId = myobj
		case "defaultThumbnail":
			myobj := &File{}
			myobj.unmarshalJSON(iter)
			c.DefaultThumbnail = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object assetInformation", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for AssetInformation
func (c *AssetInformation) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("assetKind")
	c.AssetKind.marshalJSON(stream)

	if c.GlobalAssetId != nil {
		stream.WriteObjectField("globalAssetID")
		c.GlobalAssetId.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.SpecificAssetId != nil {
		stream.WriteObjectField("specificAssetID")
		c.SpecificAssetId.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.DefaultThumbnail != nil {
		stream.WriteObjectField("defaultThumbnail")
		c.DefaultThumbnail.marshalJSON(stream)
	}

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for AssetKind
func (e AssetKind) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := AssetKind_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for AssetKind
func (e AssetKind) marshalJSON(stream *json.Stream) {
	stream.WriteString(AssetKind_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for IdentifierKeyValuePair
func (c *IdentifierKeyValuePair) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"key":   false,
		"value": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "semanticID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "key":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Key = iter.ReadString()
			isThere["key"] = true
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Value = iter.ReadString()
			isThere["value"] = true
		case "externalSubjectID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.ExternalSubjectId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object identifierKeyValuePair", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for IdentifierKeyValuePair
func (c *IdentifierKeyValuePair) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	if c.SemanticId != nil {
		stream.WriteObjectField("semanticID")
		c.SemanticId.marshalJSON(stream)
	}

	stream.WriteObjectField("key")
	stream.WriteString(c.Key)
	stream.WriteMore()

	stream.WriteObjectField("value")
	stream.WriteString(c.Value)
	stream.WriteMore()

	if c.ExternalSubjectId != nil {
		stream.WriteObjectField("externalSubjectID")
		c.ExternalSubjectId.marshalJSON(stream)
	}

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Submodel
func (c *Submodel) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"qualifiers":         false,
		"extensions":         false,
		"id":                 false,
		"submodelElements":   false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, myobj)
			}
			isThere["dataSpecifications"] = true
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ConstraintData{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, myobj)
			}
			isThere["qualifiers"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.IdShort = &val
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Category = &val
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "id":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Id = iter.ReadString()
			isThere["id"] = true
		case "administration":
			myobj := &AdministrativeInformation{}
			myobj.unmarshalJSON(iter)
			c.Administration = myobj
		case "submodelElements":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &SubmodelElementData{}
				myobj.unmarshalJSON(iter)
				c.SubmodelElements = append(c.SubmodelElements, myobj)
			}
			isThere["submodelElements"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object submodel", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Submodel
func (c *Submodel) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	if c.Kind != nil {
		stream.WriteObjectField("kind")
		c.Kind.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.SemanticId != nil {
		stream.WriteObjectField("semanticID")
		c.SemanticId.marshalJSON(stream)
		stream.WriteMore()
	}

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	if c.IdShort != nil {
		stream.WriteObjectField("idShort")
		stream.WriteString(*c.IdShort)
		stream.WriteMore()
	}

	if c.DisplayName != nil {
		stream.WriteObjectField("displayName")
		c.DisplayName.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Category != nil {
		stream.WriteObjectField("category")
		stream.WriteString(*c.Category)
		stream.WriteMore()
	}

	if c.Description != nil {
		stream.WriteObjectField("description")
		c.Description.marshalJSON(stream)
		stream.WriteMore()
	}

	stream.WriteObjectField("id")
	stream.WriteString(c.Id)
	stream.WriteMore()

	if c.Administration != nil {
		stream.WriteObjectField("administration")
		c.Administration.marshalJSON(stream)
		stream.WriteMore()
	}

	stream.WriteObjectField("submodelElements")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.SubmodelElements {
		k.marshalJSON(stream)
		if i < len(c.SubmodelElements)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for SubmodelElementData
func (d *SubmodelElementData) unmarshalJSON(iter *json.Iterator) {
	c := struct {
		// Shared Properties
		DataSpecifications []*ReferenceData
		Extensions         []*Extension
		IdShort            *string
		DisplayName        *LangStringSet
		Category           *string
		Description        *LangStringSet
		Kind               *ModelingKind
		SemanticId         *ReferenceData
		Qualifiers         []*ConstraintData
		// Used in AnnotatedRelationshipElement
		First *ReferenceData
		// Used in AnnotatedRelationshipElement
		Second *ReferenceData
		// Used in AnnotatedRelationshipElement
		Annotation []*DataElementData
		// Used in BasicEvent
		Observed *Referable
		// Used in Blob + File
		MimeType *string
		// Used in Blob
		Content *[]byte
		// Used in Entity
		EntityType *EntityType
		// Used in Entity
		Statements []*SubmodelElementData
		// Used in Entity
		GlobalAssetId *ReferenceData
		// Used in Entity
		SpecificAssetId *IdentifierKeyValuePair
		// Used in File + Property
		Value *string
		// Used in MultiLanguageProperty
		Translatable *LangStringSet
		// Used in MultiLanguageProperty + Property
		ValueId *ReferenceData
		// Used in Operation
		InputVariables []*OperationVariable
		// Used in Operation
		OutputVariables []*OperationVariable
		// Used in Operation
		InoutputVariables []*OperationVariable
		// Used in Property + Range
		ValueType *DataTypeDef
		// Used in Range
		Min *string
		// Used in Range
		Max *string
		// Used in ReferenceElement
		Reference *ReferenceData
		// Used in SubmodelElementList
		SubmodelElementTypeValues *SubmodelElements
		// Used in SubmodelElementList + SubmodelElementStruct
		Values []*SubmodelElementData
		// Used in SubmodelElementList
		SemanticIdValues *ReferenceData
		// Used in SubmodelElementList
		ValueTypeValues *DataTypeDef
	}{}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications": // loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, myobj)
			}
		case "extensions": // loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, myobj)
			}
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.IdShort = &val
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Category = &val
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers": // loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ConstraintData{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, myobj)
			}
		case "first":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.First = myobj
		case "second":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.Second = myobj
		case "annotation":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &DataElementData{}
				myobj.unmarshalJSON(iter)
				c.Annotation = append(c.Annotation, myobj)
			}
		case "observed":
		case "mimeType":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.MimeType = &val
		case "content":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Content = &val
		case "entityType":
			var myenum EntityType
			myenum.unmarshalJSON(iter)
			c.EntityType = &myenum
		case "statements":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &SubmodelElementData{}
				myobj.unmarshalJSON(iter)
				c.Statements = append(c.Statements, myobj)
			}
		case "globalAssetID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.GlobalAssetId = myobj
		case "specificAssetID":
			myobj := &IdentifierKeyValuePair{}
			myobj.unmarshalJSON(iter)
			c.SpecificAssetId = myobj
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Value = &val
		case "translatable":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Translatable = myobj
		case "valueID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.ValueId = myobj
		case "inputVariables":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &OperationVariable{}
				myobj.unmarshalJSON(iter)
				c.InputVariables = append(c.InputVariables, myobj)
			}
		case "outputVariables":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &OperationVariable{}
				myobj.unmarshalJSON(iter)
				c.OutputVariables = append(c.OutputVariables, myobj)
			}
		case "inoutputVariables":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &OperationVariable{}
				myobj.unmarshalJSON(iter)
				c.InoutputVariables = append(c.InoutputVariables, myobj)
			}
		case "valueType":
			var myenum DataTypeDef
			myenum.unmarshalJSON(iter)
			c.ValueType = &myenum
		case "min":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Min = &val
		case "max":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Max = &val
		case "reference":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.Reference = myobj
		case "submodelElementTypeValues":
			var myenum SubmodelElements
			myenum.unmarshalJSON(iter)
			c.SubmodelElementTypeValues = &myenum
		case "values":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &SubmodelElementData{}
				myobj.unmarshalJSON(iter)
				c.Values = append(c.Values, myobj)
			}
		case "semanticIDValues":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticIdValues = myobj
		case "valueTypeValues":
			var myenum DataTypeDef
			myenum.unmarshalJSON(iter)
			c.ValueTypeValues = &myenum
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object", f))
		}

		// Check if element is of type AnnotatedRelationshipElement
		if c.First != nil && c.Second != nil && c.Annotation != nil {
			// Construct AnnotatedRelationshipElement
			var obj *AnnotatedRelationshipElement
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Annotation = c.Annotation
			// Assign obj to SubmodelElementData
			d.AnnotatedRelationshipElement = obj
		} else if // Check if element is of type BasicEvent
		c.Observed != nil {
			// Construct BasicEvent
			var obj *BasicEvent
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			// Assign obj to SubmodelElementData
			d.BasicEvent = obj
		} else if // Check if element is of type Blob
		c.MimeType != nil && c.Content != nil {
			// Construct Blob
			var obj *Blob
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Content = c.Content
			// Assign obj to SubmodelElementData
			d.Blob = obj
		} else if // Check if element is of type Entity
		c.EntityType != nil && c.Statements != nil && c.GlobalAssetId != nil && c.SpecificAssetId != nil {
			// Construct Entity
			var obj *Entity
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Statements = c.Statements
			obj.GlobalAssetId = c.GlobalAssetId
			obj.SpecificAssetId = c.SpecificAssetId
			// Assign obj to SubmodelElementData
			d.Entity = obj
		} else if // Check if element is of type File
		c.MimeType != nil && c.Value != nil {
			// Construct File
			var obj *File
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Value = c.Value
			// Assign obj to SubmodelElementData
			d.File = obj
		} else if // Check if element is of type MultiLanguageProperty
		c.Translatable != nil && c.ValueId != nil {
			// Construct MultiLanguageProperty
			var obj *MultiLanguageProperty
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Translatable = c.Translatable
			obj.ValueId = c.ValueId
			// Assign obj to SubmodelElementData
			d.MultiLanguageProperty = obj
		} else if // Check if element is of type Operation
		c.InputVariables != nil && c.OutputVariables != nil && c.InoutputVariables != nil {
			// Construct Operation
			var obj *Operation
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.InputVariables = c.InputVariables
			obj.OutputVariables = c.OutputVariables
			obj.InoutputVariables = c.InoutputVariables
			// Assign obj to SubmodelElementData
			d.Operation = obj
		} else if // Check if element is of type Property
		c.ValueType != nil && c.Value != nil && c.ValueId != nil {
			// Construct Property
			var obj *Property
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Value = c.Value
			obj.ValueId = c.ValueId
			// Assign obj to SubmodelElementData
			d.Property = obj
		} else if // Check if element is of type Range
		c.ValueType != nil && c.Min != nil && c.Max != nil {
			// Construct Range
			var obj *Range
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Min = c.Min
			obj.Max = c.Max
			// Assign obj to SubmodelElementData
			d.Range = obj
		} else if // Check if element is of type ReferenceElement
		c.Reference != nil {
			// Construct ReferenceElement
			var obj *ReferenceElement
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Reference = c.Reference
			// Assign obj to SubmodelElementData
			d.ReferenceElement = obj
		} else if // Check if element is of type SubmodelElementList
		c.SubmodelElementTypeValues != nil && c.Values != nil && c.SemanticIdValues != nil && c.ValueTypeValues != nil {
			// Construct SubmodelElementList
			var obj *SubmodelElementList
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Values = c.Values
			obj.SemanticIdValues = c.SemanticIdValues
			obj.ValueTypeValues = c.ValueTypeValues
			// Assign obj to SubmodelElementData
			d.SubmodelElementList = obj
		} else if // Check if element is of type SubmodelElementStruct
		c.Values != nil {
			// Construct SubmodelElementStruct
			var obj *SubmodelElementStruct
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Values = c.Values
			// Assign obj to SubmodelElementData
			d.SubmodelElementStruct = obj
		}
	}
}

// marshalJSON implements Marshaler interface for SubmodelElementData
func (d *SubmodelElementData) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
}

// unmarshalJSON implements the Unmarshaler interface for SubmodelElementList
func (c *SubmodelElementList) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications":        false,
		"extensions":                false,
		"qualifiers":                false,
		"submodelElementTypeValues": false,
		"values":                    false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.IdShort = &val
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Category = &val
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ConstraintData{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, myobj)
			}
			isThere["qualifiers"] = true
		case "submodelElementTypeValues":
			var myenum SubmodelElements
			myenum.unmarshalJSON(iter)
			c.SubmodelElementTypeValues = myenum
			isThere["submodelElementTypeValues"] = true
		case "values":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &SubmodelElementData{}
				myobj.unmarshalJSON(iter)
				c.Values = append(c.Values, myobj)
			}
			isThere["values"] = true
		case "semanticIDValues":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticIdValues = myobj
		case "valueTypeValues":
			var myenum DataTypeDef
			myenum.unmarshalJSON(iter)
			c.ValueTypeValues = &myenum
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object submodelElementList", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for SubmodelElementList
func (c *SubmodelElementList) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	if c.IdShort != nil {
		stream.WriteObjectField("idShort")
		stream.WriteString(*c.IdShort)
		stream.WriteMore()
	}

	if c.DisplayName != nil {
		stream.WriteObjectField("displayName")
		c.DisplayName.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Category != nil {
		stream.WriteObjectField("category")
		stream.WriteString(*c.Category)
		stream.WriteMore()
	}

	if c.Description != nil {
		stream.WriteObjectField("description")
		c.Description.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Kind != nil {
		stream.WriteObjectField("kind")
		c.Kind.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.SemanticId != nil {
		stream.WriteObjectField("semanticID")
		c.SemanticId.marshalJSON(stream)
		stream.WriteMore()
	}

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("submodelElementTypeValues")
	c.SubmodelElementTypeValues.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("values")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Values {
		k.marshalJSON(stream)
		if i < len(c.Values)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	if c.SemanticIdValues != nil {
		stream.WriteObjectField("semanticIDValues")
		c.SemanticIdValues.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.ValueTypeValues != nil {
		stream.WriteObjectField("valueTypeValues")
		c.ValueTypeValues.marshalJSON(stream)
	}

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for SubmodelElementStruct
func (c *SubmodelElementStruct) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"values":             false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.IdShort = &val
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Category = &val
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ConstraintData{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, myobj)
			}
			isThere["qualifiers"] = true
		case "values":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &SubmodelElementData{}
				myobj.unmarshalJSON(iter)
				c.Values = append(c.Values, myobj)
			}
			isThere["values"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object submodelElementStruct", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for SubmodelElementStruct
func (c *SubmodelElementStruct) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	if c.IdShort != nil {
		stream.WriteObjectField("idShort")
		stream.WriteString(*c.IdShort)
		stream.WriteMore()
	}

	if c.DisplayName != nil {
		stream.WriteObjectField("displayName")
		c.DisplayName.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Category != nil {
		stream.WriteObjectField("category")
		stream.WriteString(*c.Category)
		stream.WriteMore()
	}

	if c.Description != nil {
		stream.WriteObjectField("description")
		c.Description.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Kind != nil {
		stream.WriteObjectField("kind")
		c.Kind.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.SemanticId != nil {
		stream.WriteObjectField("semanticID")
		c.SemanticId.marshalJSON(stream)
		stream.WriteMore()
	}

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("values")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Values {
		k.marshalJSON(stream)
		if i < len(c.Values)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for DataElementData
func (d *DataElementData) unmarshalJSON(iter *json.Iterator) {
	c := struct {
		// Shared Properties
		DataSpecifications []*ReferenceData
		Extensions         []*Extension
		IdShort            *string
		DisplayName        *LangStringSet
		Category           *string
		Description        *LangStringSet
		Kind               *ModelingKind
		SemanticId         *ReferenceData
		Qualifiers         []*ConstraintData
		// Used in Blob + File
		MimeType *string
		// Used in Blob
		Content *[]byte
		// Used in File + Property
		Value *string
		// Used in MultiLanguageProperty
		Translatable *LangStringSet
		// Used in MultiLanguageProperty + Property
		ValueId *ReferenceData
		// Used in Property + Range
		ValueType *DataTypeDef
		// Used in Range
		Min *string
		// Used in Range
		Max *string
		// Used in ReferenceElement
		Reference *ReferenceData
	}{}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications": // loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, myobj)
			}
		case "extensions": // loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, myobj)
			}
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.IdShort = &val
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Category = &val
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers": // loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ConstraintData{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, myobj)
			}
		case "mimeType":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.MimeType = &val
		case "content":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Content = &val
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Value = &val
		case "translatable":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Translatable = myobj
		case "valueID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.ValueId = myobj
		case "valueType":
			var myenum DataTypeDef
			myenum.unmarshalJSON(iter)
			c.ValueType = &myenum
		case "min":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Min = &val
		case "max":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Max = &val
		case "reference":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.Reference = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object", f))
		}

		// Check if element is of type Blob
		if c.MimeType != nil && c.Content != nil {
			// Construct Blob
			var obj *Blob
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Content = c.Content
			// Assign obj to DataElementData
			d.Blob = obj
		} else if // Check if element is of type File
		c.MimeType != nil && c.Value != nil {
			// Construct File
			var obj *File
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Value = c.Value
			// Assign obj to DataElementData
			d.File = obj
		} else if // Check if element is of type MultiLanguageProperty
		c.Translatable != nil && c.ValueId != nil {
			// Construct MultiLanguageProperty
			var obj *MultiLanguageProperty
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Translatable = c.Translatable
			obj.ValueId = c.ValueId
			// Assign obj to DataElementData
			d.MultiLanguageProperty = obj
		} else if // Check if element is of type Property
		c.ValueType != nil && c.Value != nil && c.ValueId != nil {
			// Construct Property
			var obj *Property
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Value = c.Value
			obj.ValueId = c.ValueId
			// Assign obj to DataElementData
			d.Property = obj
		} else if // Check if element is of type Range
		c.ValueType != nil && c.Min != nil && c.Max != nil {
			// Construct Range
			var obj *Range
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Min = c.Min
			obj.Max = c.Max
			// Assign obj to DataElementData
			d.Range = obj
		} else if // Check if element is of type ReferenceElement
		c.Reference != nil {
			// Construct ReferenceElement
			var obj *ReferenceElement
			obj.DataSpecifications = c.DataSpecifications
			obj.Extensions = c.Extensions
			obj.IdShort = c.IdShort
			obj.DisplayName = c.DisplayName
			obj.Category = c.Category
			obj.Description = c.Description
			obj.Kind = c.Kind
			obj.SemanticId = c.SemanticId
			obj.Qualifiers = c.Qualifiers
			obj.Reference = c.Reference
			// Assign obj to DataElementData
			d.ReferenceElement = obj
		}
	}
}

// marshalJSON implements Marshaler interface for DataElementData
func (d *DataElementData) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
}

// unmarshalJSON implements the Unmarshaler interface for Property
func (c *Property) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"valueType":          false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.IdShort = &val
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Category = &val
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ConstraintData{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, myobj)
			}
			isThere["qualifiers"] = true
		case "valueType":
			var myenum DataTypeDef
			myenum.unmarshalJSON(iter)
			c.ValueType = myenum
			isThere["valueType"] = true
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Value = &val
		case "valueID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.ValueId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object property", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Property
func (c *Property) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	if c.IdShort != nil {
		stream.WriteObjectField("idShort")
		stream.WriteString(*c.IdShort)
		stream.WriteMore()
	}

	if c.DisplayName != nil {
		stream.WriteObjectField("displayName")
		c.DisplayName.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Category != nil {
		stream.WriteObjectField("category")
		stream.WriteString(*c.Category)
		stream.WriteMore()
	}

	if c.Description != nil {
		stream.WriteObjectField("description")
		c.Description.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Kind != nil {
		stream.WriteObjectField("kind")
		c.Kind.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.SemanticId != nil {
		stream.WriteObjectField("semanticID")
		c.SemanticId.marshalJSON(stream)
		stream.WriteMore()
	}

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("valueType")
	c.ValueType.marshalJSON(stream)
	stream.WriteMore()

	if c.Value != nil {
		stream.WriteObjectField("value")
		stream.WriteString(*c.Value)
		stream.WriteMore()
	}

	if c.ValueId != nil {
		stream.WriteObjectField("valueID")
		c.ValueId.marshalJSON(stream)
	}

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for MultiLanguageProperty
func (c *MultiLanguageProperty) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.IdShort = &val
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Category = &val
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ConstraintData{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, myobj)
			}
			isThere["qualifiers"] = true
		case "translatable":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Translatable = myobj
		case "valueID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.ValueId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object multiLanguageProperty", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for MultiLanguageProperty
func (c *MultiLanguageProperty) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	if c.IdShort != nil {
		stream.WriteObjectField("idShort")
		stream.WriteString(*c.IdShort)
		stream.WriteMore()
	}

	if c.DisplayName != nil {
		stream.WriteObjectField("displayName")
		c.DisplayName.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Category != nil {
		stream.WriteObjectField("category")
		stream.WriteString(*c.Category)
		stream.WriteMore()
	}

	if c.Description != nil {
		stream.WriteObjectField("description")
		c.Description.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Kind != nil {
		stream.WriteObjectField("kind")
		c.Kind.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.SemanticId != nil {
		stream.WriteObjectField("semanticID")
		c.SemanticId.marshalJSON(stream)
		stream.WriteMore()
	}

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	if c.Translatable != nil {
		stream.WriteObjectField("translatable")
		c.Translatable.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.ValueId != nil {
		stream.WriteObjectField("valueID")
		c.ValueId.marshalJSON(stream)
	}

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Range
func (c *Range) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"valueType":          false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.IdShort = &val
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Category = &val
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ConstraintData{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, myobj)
			}
			isThere["qualifiers"] = true
		case "valueType":
			var myenum DataTypeDef
			myenum.unmarshalJSON(iter)
			c.ValueType = myenum
			isThere["valueType"] = true
		case "min":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Min = &val
		case "max":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Max = &val
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object range", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Range
func (c *Range) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	if c.IdShort != nil {
		stream.WriteObjectField("idShort")
		stream.WriteString(*c.IdShort)
		stream.WriteMore()
	}

	if c.DisplayName != nil {
		stream.WriteObjectField("displayName")
		c.DisplayName.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Category != nil {
		stream.WriteObjectField("category")
		stream.WriteString(*c.Category)
		stream.WriteMore()
	}

	if c.Description != nil {
		stream.WriteObjectField("description")
		c.Description.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Kind != nil {
		stream.WriteObjectField("kind")
		c.Kind.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.SemanticId != nil {
		stream.WriteObjectField("semanticID")
		c.SemanticId.marshalJSON(stream)
		stream.WriteMore()
	}

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("valueType")
	c.ValueType.marshalJSON(stream)
	stream.WriteMore()

	if c.Min != nil {
		stream.WriteObjectField("min")
		stream.WriteString(*c.Min)
		stream.WriteMore()
	}

	if c.Max != nil {
		stream.WriteObjectField("max")
		stream.WriteString(*c.Max)
	}

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for ReferenceElement
func (c *ReferenceElement) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.IdShort = &val
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Category = &val
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ConstraintData{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, myobj)
			}
			isThere["qualifiers"] = true
		case "reference":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.Reference = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object referenceElement", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for ReferenceElement
func (c *ReferenceElement) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	if c.IdShort != nil {
		stream.WriteObjectField("idShort")
		stream.WriteString(*c.IdShort)
		stream.WriteMore()
	}

	if c.DisplayName != nil {
		stream.WriteObjectField("displayName")
		c.DisplayName.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Category != nil {
		stream.WriteObjectField("category")
		stream.WriteString(*c.Category)
		stream.WriteMore()
	}

	if c.Description != nil {
		stream.WriteObjectField("description")
		c.Description.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Kind != nil {
		stream.WriteObjectField("kind")
		c.Kind.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.SemanticId != nil {
		stream.WriteObjectField("semanticID")
		c.SemanticId.marshalJSON(stream)
		stream.WriteMore()
	}

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	if c.Reference != nil {
		stream.WriteObjectField("reference")
		c.Reference.marshalJSON(stream)
	}

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Blob
func (c *Blob) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"mimeType":           false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.IdShort = &val
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Category = &val
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ConstraintData{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, myobj)
			}
			isThere["qualifiers"] = true
		case "mimeType":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.MimeType = iter.ReadString()
			isThere["mimeType"] = true
		case "content":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Content = &val
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object blob", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Blob
func (c *Blob) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	if c.IdShort != nil {
		stream.WriteObjectField("idShort")
		stream.WriteString(*c.IdShort)
		stream.WriteMore()
	}

	if c.DisplayName != nil {
		stream.WriteObjectField("displayName")
		c.DisplayName.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Category != nil {
		stream.WriteObjectField("category")
		stream.WriteString(*c.Category)
		stream.WriteMore()
	}

	if c.Description != nil {
		stream.WriteObjectField("description")
		c.Description.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Kind != nil {
		stream.WriteObjectField("kind")
		c.Kind.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.SemanticId != nil {
		stream.WriteObjectField("semanticID")
		c.SemanticId.marshalJSON(stream)
		stream.WriteMore()
	}

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("mimeType")
	stream.WriteString(c.MimeType)
	stream.WriteMore()

	if c.Content != nil {
		stream.WriteObjectField("content")
		stream.WriteString(*c.Content)
	}

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for File
func (c *File) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"mimeType":           false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.IdShort = &val
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Category = &val
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ConstraintData{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, myobj)
			}
			isThere["qualifiers"] = true
		case "mimeType":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.MimeType = iter.ReadString()
			isThere["mimeType"] = true
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Value = &val
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object file", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for File
func (c *File) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	if c.IdShort != nil {
		stream.WriteObjectField("idShort")
		stream.WriteString(*c.IdShort)
		stream.WriteMore()
	}

	if c.DisplayName != nil {
		stream.WriteObjectField("displayName")
		c.DisplayName.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Category != nil {
		stream.WriteObjectField("category")
		stream.WriteString(*c.Category)
		stream.WriteMore()
	}

	if c.Description != nil {
		stream.WriteObjectField("description")
		c.Description.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Kind != nil {
		stream.WriteObjectField("kind")
		c.Kind.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.SemanticId != nil {
		stream.WriteObjectField("semanticID")
		c.SemanticId.marshalJSON(stream)
		stream.WriteMore()
	}

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("mimeType")
	stream.WriteString(c.MimeType)
	stream.WriteMore()

	if c.Value != nil {
		stream.WriteObjectField("value")
		stream.WriteString(*c.Value)
	}

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for AnnotatedRelationshipElement
func (c *AnnotatedRelationshipElement) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"first":              false,
		"second":             false,
		"annotation":         false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.IdShort = &val
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Category = &val
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ConstraintData{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, myobj)
			}
			isThere["qualifiers"] = true
		case "first":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			isThere["first"] = true
			c.First = myobj
		case "second":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			isThere["second"] = true
			c.Second = myobj
		case "annotation":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &DataElementData{}
				myobj.unmarshalJSON(iter)
				c.Annotation = append(c.Annotation, myobj)
			}
			isThere["annotation"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object annotatedRelationshipElement", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for AnnotatedRelationshipElement
func (c *AnnotatedRelationshipElement) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	if c.IdShort != nil {
		stream.WriteObjectField("idShort")
		stream.WriteString(*c.IdShort)
		stream.WriteMore()
	}

	if c.DisplayName != nil {
		stream.WriteObjectField("displayName")
		c.DisplayName.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Category != nil {
		stream.WriteObjectField("category")
		stream.WriteString(*c.Category)
		stream.WriteMore()
	}

	if c.Description != nil {
		stream.WriteObjectField("description")
		c.Description.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Kind != nil {
		stream.WriteObjectField("kind")
		c.Kind.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.SemanticId != nil {
		stream.WriteObjectField("semanticID")
		c.SemanticId.marshalJSON(stream)
		stream.WriteMore()
	}

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("first")
	c.First.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("second")
	c.Second.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("annotation")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Annotation {
		k.marshalJSON(stream)
		if i < len(c.Annotation)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for EntityType
func (e EntityType) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := EntityType_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for EntityType
func (e EntityType) marshalJSON(stream *json.Stream) {
	stream.WriteString(EntityType_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for Entity
func (c *Entity) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"entityType":         false,
		"statements":         false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.IdShort = &val
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Category = &val
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ConstraintData{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, myobj)
			}
			isThere["qualifiers"] = true
		case "entityType":
			var myenum EntityType
			myenum.unmarshalJSON(iter)
			c.EntityType = myenum
			isThere["entityType"] = true
		case "statements":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &SubmodelElementData{}
				myobj.unmarshalJSON(iter)
				c.Statements = append(c.Statements, myobj)
			}
			isThere["statements"] = true
		case "globalAssetID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.GlobalAssetId = myobj
		case "specificAssetID":
			myobj := &IdentifierKeyValuePair{}
			myobj.unmarshalJSON(iter)
			c.SpecificAssetId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object entity", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Entity
func (c *Entity) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	if c.IdShort != nil {
		stream.WriteObjectField("idShort")
		stream.WriteString(*c.IdShort)
		stream.WriteMore()
	}

	if c.DisplayName != nil {
		stream.WriteObjectField("displayName")
		c.DisplayName.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Category != nil {
		stream.WriteObjectField("category")
		stream.WriteString(*c.Category)
		stream.WriteMore()
	}

	if c.Description != nil {
		stream.WriteObjectField("description")
		c.Description.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Kind != nil {
		stream.WriteObjectField("kind")
		c.Kind.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.SemanticId != nil {
		stream.WriteObjectField("semanticID")
		c.SemanticId.marshalJSON(stream)
		stream.WriteMore()
	}

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("entityType")
	c.EntityType.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("statements")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Statements {
		k.marshalJSON(stream)
		if i < len(c.Statements)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	if c.GlobalAssetId != nil {
		stream.WriteObjectField("globalAssetID")
		c.GlobalAssetId.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.SpecificAssetId != nil {
		stream.WriteObjectField("specificAssetID")
		c.SpecificAssetId.marshalJSON(stream)
	}

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for BasicEvent
func (c *BasicEvent) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"observed":           false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.IdShort = &val
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Category = &val
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ConstraintData{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, myobj)
			}
			isThere["qualifiers"] = true
		case "observed":
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object basicEvent", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for BasicEvent
func (c *BasicEvent) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	if c.IdShort != nil {
		stream.WriteObjectField("idShort")
		stream.WriteString(*c.IdShort)
		stream.WriteMore()
	}

	if c.DisplayName != nil {
		stream.WriteObjectField("displayName")
		c.DisplayName.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Category != nil {
		stream.WriteObjectField("category")
		stream.WriteString(*c.Category)
		stream.WriteMore()
	}

	if c.Description != nil {
		stream.WriteObjectField("description")
		c.Description.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Kind != nil {
		stream.WriteObjectField("kind")
		c.Kind.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.SemanticId != nil {
		stream.WriteObjectField("semanticID")
		c.SemanticId.marshalJSON(stream)
		stream.WriteMore()
	}

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("observed")

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Operation
func (c *Operation) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"inputVariables":     false,
		"outputVariables":    false,
		"inoutputVariables":  false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.IdShort = &val
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Category = &val
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ConstraintData{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, myobj)
			}
			isThere["qualifiers"] = true
		case "inputVariables":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &OperationVariable{}
				myobj.unmarshalJSON(iter)
				c.InputVariables = append(c.InputVariables, myobj)
			}
			isThere["inputVariables"] = true
		case "outputVariables":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &OperationVariable{}
				myobj.unmarshalJSON(iter)
				c.OutputVariables = append(c.OutputVariables, myobj)
			}
			isThere["outputVariables"] = true
		case "inoutputVariables":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &OperationVariable{}
				myobj.unmarshalJSON(iter)
				c.InoutputVariables = append(c.InoutputVariables, myobj)
			}
			isThere["inoutputVariables"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object operation", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Operation
func (c *Operation) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	if c.IdShort != nil {
		stream.WriteObjectField("idShort")
		stream.WriteString(*c.IdShort)
		stream.WriteMore()
	}

	if c.DisplayName != nil {
		stream.WriteObjectField("displayName")
		c.DisplayName.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Category != nil {
		stream.WriteObjectField("category")
		stream.WriteString(*c.Category)
		stream.WriteMore()
	}

	if c.Description != nil {
		stream.WriteObjectField("description")
		c.Description.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Kind != nil {
		stream.WriteObjectField("kind")
		c.Kind.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.SemanticId != nil {
		stream.WriteObjectField("semanticID")
		c.SemanticId.marshalJSON(stream)
		stream.WriteMore()
	}

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("inputVariables")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.InputVariables {
		k.marshalJSON(stream)
		if i < len(c.InputVariables)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("outputVariables")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.OutputVariables {
		k.marshalJSON(stream)
		if i < len(c.OutputVariables)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("inoutputVariables")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.InoutputVariables {
		k.marshalJSON(stream)
		if i < len(c.InoutputVariables)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for OperationVariable
func (c *OperationVariable) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"value": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "value":
			myobj := &SubmodelElementData{}
			myobj.unmarshalJSON(iter)
			isThere["value"] = true
			c.Value = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object operationVariable", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for OperationVariable
func (c *OperationVariable) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("value")
	c.Value.marshalJSON(stream)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Capability
func (c *Capability) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.IdShort = &val
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Category = &val
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ConstraintData{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, myobj)
			}
			isThere["qualifiers"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object capability", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Capability
func (c *Capability) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	if c.IdShort != nil {
		stream.WriteObjectField("idShort")
		stream.WriteString(*c.IdShort)
		stream.WriteMore()
	}

	if c.DisplayName != nil {
		stream.WriteObjectField("displayName")
		c.DisplayName.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Category != nil {
		stream.WriteObjectField("category")
		stream.WriteString(*c.Category)
		stream.WriteMore()
	}

	if c.Description != nil {
		stream.WriteObjectField("description")
		c.Description.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Kind != nil {
		stream.WriteObjectField("kind")
		c.Kind.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.SemanticId != nil {
		stream.WriteObjectField("semanticID")
		c.SemanticId.marshalJSON(stream)
		stream.WriteMore()
	}

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for ConceptDescription
func (c *ConceptDescription) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"id":                 false,
		"isCaseOf":           false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.IdShort = &val
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Category = &val
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "id":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Id = iter.ReadString()
			isThere["id"] = true
		case "administration":
			myobj := &AdministrativeInformation{}
			myobj.unmarshalJSON(iter)
			c.Administration = myobj
		case "isCaseOf":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.IsCaseOf = append(c.IsCaseOf, myobj)
			}
			isThere["isCaseOf"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object conceptDescription", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for ConceptDescription
func (c *ConceptDescription) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	if c.IdShort != nil {
		stream.WriteObjectField("idShort")
		stream.WriteString(*c.IdShort)
		stream.WriteMore()
	}

	if c.DisplayName != nil {
		stream.WriteObjectField("displayName")
		c.DisplayName.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Category != nil {
		stream.WriteObjectField("category")
		stream.WriteString(*c.Category)
		stream.WriteMore()
	}

	if c.Description != nil {
		stream.WriteObjectField("description")
		c.Description.marshalJSON(stream)
		stream.WriteMore()
	}

	stream.WriteObjectField("id")
	stream.WriteString(c.Id)
	stream.WriteMore()

	if c.Administration != nil {
		stream.WriteObjectField("administration")
		c.Administration.marshalJSON(stream)
		stream.WriteMore()
	}

	stream.WriteObjectField("isCaseOf")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.IsCaseOf {
		k.marshalJSON(stream)
		if i < len(c.IsCaseOf)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for View
func (c *View) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"containedElements":  false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ReferenceData{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.IdShort = &val
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Category = &val
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "semanticID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "containedElements":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
			}
			isThere["containedElements"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object view", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for View
func (c *View) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	if c.IdShort != nil {
		stream.WriteObjectField("idShort")
		stream.WriteString(*c.IdShort)
		stream.WriteMore()
	}

	if c.DisplayName != nil {
		stream.WriteObjectField("displayName")
		c.DisplayName.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Category != nil {
		stream.WriteObjectField("category")
		stream.WriteString(*c.Category)
		stream.WriteMore()
	}

	if c.Description != nil {
		stream.WriteObjectField("description")
		c.Description.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.SemanticId != nil {
		stream.WriteObjectField("semanticID")
		c.SemanticId.marshalJSON(stream)
		stream.WriteMore()
	}

	stream.WriteObjectField("containedElements")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.ContainedElements {
		k.marshalJSON(stream)
		if i < len(c.ContainedElements)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for ReferenceData
func (d *ReferenceData) unmarshalJSON(iter *json.Iterator) {
	c := struct {
		// Shared Properties
		// Used in GlobalReference
		Values []string
		// Used in ModelReference
		Keys []*Key
		// Used in ModelReference
		ReferredSemanticId *ReferenceData
	}{}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "values":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				if next := iter.WhatIsNext(); next != json.StringValue {
					iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
				}
				val := iter.ReadString()
				c.Values = &val
			}
		case "keys":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Key{}
				myobj.unmarshalJSON(iter)
				c.Keys = append(c.Keys, myobj)
			}
		case "referredSemanticID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.ReferredSemanticId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object", f))
		}

		// Check if element is of type GlobalReference
		if c.Values != nil {
			// Construct GlobalReference
			var obj *GlobalReference
			obj.Values = c.Values
			// Assign obj to ReferenceData
			d.GlobalReference = obj
		} else if // Check if element is of type ModelReference
		c.Keys != nil && c.ReferredSemanticId != nil {
			// Construct ModelReference
			var obj *ModelReference
			obj.Keys = c.Keys
			obj.ReferredSemanticId = c.ReferredSemanticId
			// Assign obj to ReferenceData
			d.ModelReference = obj
		}
	}
}

// marshalJSON implements Marshaler interface for ReferenceData
func (d *ReferenceData) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
}

// unmarshalJSON implements the Unmarshaler interface for GlobalReference
func (c *GlobalReference) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"values": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "values":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				if next := iter.WhatIsNext(); next != json.StringValue {
					iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
				}
				c.Values = iter.ReadString()
			}
			isThere["values"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object globalReference", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for GlobalReference
func (c *GlobalReference) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("values")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Values {
		k.marshalJSON(stream)
		if i < len(c.Values)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for ModelReference
func (c *ModelReference) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"keys": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "keys":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Key{}
				myobj.unmarshalJSON(iter)
				c.Keys = append(c.Keys, myobj)
			}
			isThere["keys"] = true
		case "referredSemanticID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.ReferredSemanticId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object modelReference", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for ModelReference
func (c *ModelReference) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("keys")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Keys {
		k.marshalJSON(stream)
		if i < len(c.Keys)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	if c.ReferredSemanticId != nil {
		stream.WriteObjectField("referredSemanticID")
		c.ReferredSemanticId.marshalJSON(stream)
	}

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Key
func (c *Key) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"type":  false,
		"value": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "type":
			var myenum KeyElements
			myenum.unmarshalJSON(iter)
			c.Type = myenum
			isThere["type"] = true
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Value = iter.ReadString()
			isThere["value"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object key", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Key
func (c *Key) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("type")
	c.Type.marshalJSON(stream)

	stream.WriteObjectField("value")
	stream.WriteString(c.Value)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for IdentifiableElements
func (e IdentifiableElements) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := IdentifiableElements_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for IdentifiableElements
func (e IdentifiableElements) marshalJSON(stream *json.Stream) {
	stream.WriteString(IdentifiableElements_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for ReferableElements
func (e ReferableElements) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := ReferableElements_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for ReferableElements
func (e ReferableElements) marshalJSON(stream *json.Stream) {
	stream.WriteString(ReferableElements_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for KeyElements
func (e KeyElements) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := KeyElements_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for KeyElements
func (e KeyElements) marshalJSON(stream *json.Stream) {
	stream.WriteString(KeyElements_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for SubmodelElements
func (e SubmodelElements) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := SubmodelElements_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for SubmodelElements
func (e SubmodelElements) marshalJSON(stream *json.Stream) {
	stream.WriteString(SubmodelElements_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for BuildInListTypes
func (e BuildInListTypes) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := BuildInListTypes_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for BuildInListTypes
func (e BuildInListTypes) marshalJSON(stream *json.Stream) {
	stream.WriteString(BuildInListTypes_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for DecimalBuildInTypes
func (e DecimalBuildInTypes) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := DecimalBuildInTypes_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for DecimalBuildInTypes
func (e DecimalBuildInTypes) marshalJSON(stream *json.Stream) {
	stream.WriteString(DecimalBuildInTypes_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for DurationBuildInTypes
func (e DurationBuildInTypes) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := DurationBuildInTypes_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for DurationBuildInTypes
func (e DurationBuildInTypes) marshalJSON(stream *json.Stream) {
	stream.WriteString(DurationBuildInTypes_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for PrimitiveTypes
func (e PrimitiveTypes) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := PrimitiveTypes_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for PrimitiveTypes
func (e PrimitiveTypes) marshalJSON(stream *json.Stream) {
	stream.WriteString(PrimitiveTypes_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for StringBuildInTypes
func (e StringBuildInTypes) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := StringBuildInTypes_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for StringBuildInTypes
func (e StringBuildInTypes) marshalJSON(stream *json.Stream) {
	stream.WriteString(StringBuildInTypes_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for DataTypeDef
func (e DataTypeDef) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := DataTypeDef_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for DataTypeDef
func (e DataTypeDef) marshalJSON(stream *json.Stream) {
	stream.WriteString(DataTypeDef_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for LangStringSet
func (c *LangStringSet) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object langStringSet", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for LangStringSet
func (c *LangStringSet) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for DataTypeIec61360
func (e DataTypeIec61360) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := DataTypeIec61360_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for DataTypeIec61360
func (e DataTypeIec61360) marshalJSON(stream *json.Stream) {
	stream.WriteString(DataTypeIec61360_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for LevelType
func (e LevelType) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := LevelType_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for LevelType
func (e LevelType) marshalJSON(stream *json.Stream) {
	stream.WriteString(LevelType_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for ValueReferencePair
func (c *ValueReferencePair) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"value":   false,
		"valueID": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Value = iter.ReadString()
			isThere["value"] = true
		case "valueID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			isThere["valueID"] = true
			c.ValueId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object valueReferencePair", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for ValueReferencePair
func (c *ValueReferencePair) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("value")
	stream.WriteString(c.Value)

	stream.WriteObjectField("valueID")
	c.ValueId.marshalJSON(stream)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for ValueList
func (c *ValueList) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"valueReferencePairs": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "valueReferencePairs":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ValueReferencePair{}
				myobj.unmarshalJSON(iter)
				c.ValueReferencePairs = append(c.ValueReferencePairs, myobj)
			}
			isThere["valueReferencePairs"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object valueList", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for ValueList
func (c *ValueList) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("valueReferencePairs")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.ValueReferencePairs {
		k.marshalJSON(stream)
		if i < len(c.ValueReferencePairs)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for DataSpecificationIec61360
func (c *DataSpecificationIec61360) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "preferredName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.PreferredName = myobj
		case "shortName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.ShortName = myobj
		case "unit":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Unit = &val
		case "unitID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.UnitId = myobj
		case "sourceOfDefinition":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.SourceOfDefinition = &val
		case "symbol":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Symbol = &val
		case "dataType":
			var myenum DataTypeIec61360
			myenum.unmarshalJSON(iter)
			c.DataType = &myenum
		case "definition":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Definition = myobj
		case "valueFormat":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.ValueFormat = &val
		case "valueList":
			myobj := &ValueList{}
			myobj.unmarshalJSON(iter)
			c.ValueList = myobj
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Value = &val
		case "valueID":
			myobj := &ReferenceData{}
			myobj.unmarshalJSON(iter)
			c.ValueId = myobj
		case "levelType":
			var myenum LevelType
			myenum.unmarshalJSON(iter)
			c.LevelType = &myenum
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object dataSpecificationIec61360", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for DataSpecificationIec61360
func (c *DataSpecificationIec61360) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	if c.PreferredName != nil {
		stream.WriteObjectField("preferredName")
		c.PreferredName.marshalJSON(stream)
	}

	if c.ShortName != nil {
		stream.WriteObjectField("shortName")
		c.ShortName.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Unit != nil {
		stream.WriteObjectField("unit")
		stream.WriteString(*c.Unit)
		stream.WriteMore()
	}

	if c.UnitId != nil {
		stream.WriteObjectField("unitID")
		c.UnitId.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.SourceOfDefinition != nil {
		stream.WriteObjectField("sourceOfDefinition")
		stream.WriteString(*c.SourceOfDefinition)
		stream.WriteMore()
	}

	if c.Symbol != nil {
		stream.WriteObjectField("symbol")
		stream.WriteString(*c.Symbol)
		stream.WriteMore()
	}

	if c.DataType != nil {
		stream.WriteObjectField("dataType")
		c.DataType.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Definition != nil {
		stream.WriteObjectField("definition")
		c.Definition.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.ValueFormat != nil {
		stream.WriteObjectField("valueFormat")
		stream.WriteString(*c.ValueFormat)
		stream.WriteMore()
	}

	if c.ValueList != nil {
		stream.WriteObjectField("valueList")
		c.ValueList.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.Value != nil {
		stream.WriteObjectField("value")
		stream.WriteString(*c.Value)
		stream.WriteMore()
	}

	if c.ValueId != nil {
		stream.WriteObjectField("valueID")
		c.ValueId.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.LevelType != nil {
		stream.WriteObjectField("levelType")
		c.LevelType.marshalJSON(stream)
	}

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for DataSpecificationPhysicalUnit
func (c *DataSpecificationPhysicalUnit) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "unitName":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.UnitName = &val
		case "unitSymbol":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.UnitSymbol = &val
		case "definition":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Definition = myobj
		case "siNotation":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.SiNotation = &val
		case "dinNotation":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.DinNotation = &val
		case "eceName":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.EceName = &val
		case "eceCode":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.EceCode = &val
		case "nistName":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.NistName = &val
		case "sourceOfDefinition":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.SourceOfDefinition = &val
		case "conversionFactor":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.ConversionFactor = &val
		case "registrationAuthorityID":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.RegistrationAuthorityId = &val
		case "supplier":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			val := iter.ReadString()
			c.Supplier = &val
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object dataSpecificationPhysicalUnit", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for DataSpecificationPhysicalUnit
func (c *DataSpecificationPhysicalUnit) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	if c.UnitName != nil {
		stream.WriteObjectField("unitName")
		stream.WriteString(*c.UnitName)
	}

	if c.UnitSymbol != nil {
		stream.WriteObjectField("unitSymbol")
		stream.WriteString(*c.UnitSymbol)
		stream.WriteMore()
	}

	if c.Definition != nil {
		stream.WriteObjectField("definition")
		c.Definition.marshalJSON(stream)
		stream.WriteMore()
	}

	if c.SiNotation != nil {
		stream.WriteObjectField("siNotation")
		stream.WriteString(*c.SiNotation)
		stream.WriteMore()
	}

	if c.DinNotation != nil {
		stream.WriteObjectField("dinNotation")
		stream.WriteString(*c.DinNotation)
		stream.WriteMore()
	}

	if c.EceName != nil {
		stream.WriteObjectField("eceName")
		stream.WriteString(*c.EceName)
		stream.WriteMore()
	}

	if c.EceCode != nil {
		stream.WriteObjectField("eceCode")
		stream.WriteString(*c.EceCode)
		stream.WriteMore()
	}

	if c.NistName != nil {
		stream.WriteObjectField("nistName")
		stream.WriteString(*c.NistName)
		stream.WriteMore()
	}

	if c.SourceOfDefinition != nil {
		stream.WriteObjectField("sourceOfDefinition")
		stream.WriteString(*c.SourceOfDefinition)
		stream.WriteMore()
	}

	if c.ConversionFactor != nil {
		stream.WriteObjectField("conversionFactor")
		stream.WriteString(*c.ConversionFactor)
		stream.WriteMore()
	}

	if c.RegistrationAuthorityId != nil {
		stream.WriteObjectField("registrationAuthorityID")
		stream.WriteString(*c.RegistrationAuthorityId)
		stream.WriteMore()
	}

	if c.Supplier != nil {
		stream.WriteObjectField("supplier")
		stream.WriteString(*c.Supplier)
	}

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Environment
func (c *Environment) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"assetAdministrationShells": false,
		"submodels":                 false,
		"conceptDescriptions":       false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "assetAdministrationShells":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &AssetAdministrationShell{}
				myobj.unmarshalJSON(iter)
				c.AssetAdministrationShells = append(c.AssetAdministrationShells, myobj)
			}
			isThere["assetAdministrationShells"] = true
		case "submodels":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Submodel{}
				myobj.unmarshalJSON(iter)
				c.Submodels = append(c.Submodels, myobj)
			}
			isThere["submodels"] = true
		case "conceptDescriptions":
			// loop through every element in the array and unmarshal it
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ConceptDescription{}
				myobj.unmarshalJSON(iter)
				c.ConceptDescriptions = append(c.ConceptDescriptions, myobj)
			}
			isThere["conceptDescriptions"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object environment", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Environment
func (c *Environment) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("assetAdministrationShells")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.AssetAdministrationShells {
		k.marshalJSON(stream)
		if i < len(c.AssetAdministrationShells)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectField("submodels")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Submodels {
		k.marshalJSON(stream)
		if i < len(c.Submodels)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("conceptDescriptions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.ConceptDescriptions {
		k.marshalJSON(stream)
		if i < len(c.ConceptDescriptions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}
