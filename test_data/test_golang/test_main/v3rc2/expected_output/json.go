// Code generated by aas-core-codegen. DO NOT EDIT.

package aascore

import (
	"fmt"
	"io"

	json "github.com/json-iterator/go"
)

// Marshaler is the interface implemented by all types of the meta-model
// that can marshal themselves into a valid JSON.
type Marshaler interface {
	marshalJSON(stream *json.Stream) error
}

// Unmarshaler is the interface implemented by all types of the meta-model
// that can unmarshal a JSON description of themselves.
type Unmarshaler interface {
	unmarshalJSON(iter *json.Iterator) error
}

// Encoder writes JSON values to an output stream.
type Encoder struct {
	stream *json.Stream
}

// Decoder reads and decodes JSON values from an input stream.
type Decoder struct {
	iter *json.Iterator
}

// NewDecoder returns a new Decoder that reads from r.
// Bs is the internal buffer size set in the NewDecoder.
func NewDecoder(bs int, r io.Reader) *Decoder {
	iter := json.Parse(json.ConfigDefault, r, bs)
	return &Decoder{iter}
}

// NewEcoder returns a new Encoder that writes to w.
// Bs is the internal buffer size set in the NewEncoder.
func NewEncoder(bs int, w io.Writer) *Encoder {
	stream := json.NewStream(json.ConfigDefault, w, bs)
	return &Encoder{stream}
}

// Decode reads the next encoded value from its input and
// writes it in the value pointed to by v. V must implement
// the Unmarshaler interface.
func (d *Decoder) Decode(v Unmarshaler) error {
	v.unmarshalJSON(d.iter)
	err := d.iter.Error
	if err == io.EOF {
		return nil
	}
	return d.iter.Error
}

// Encode writes the encoding of v to the input stream v
// V must implement the Marshaler interface.
func (e *Encoder) Encode(v Marshaler) error {
	v.marshalJSON(e.stream)
	e.stream.WriteRaw("\n")
	e.stream.Flush()
	return e.stream.Error
}

func (c *HasSemantics) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object hasSemantics", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *HasSemantics) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)

	stream.WriteObjectEnd()
}

func (c *Extension) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"name": false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "name":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Name = iter.ReadString()
			isThere["name"] = true
		case "valueType":
			var myenum DataTypeDef
			myenum.unmarshalJSON(iter)
			c.ValueType = &myenum
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Value = iter.ReadString()
		case "refersTo":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.RefersTo = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object extension", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *Extension) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("name")
	stream.WriteMore()

	stream.WriteString(c.Name)
	stream.WriteObjectField("valueType")
	stream.WriteMore()

	c.ValueType.marshalJSON(stream)
	stream.WriteObjectField("value")
	stream.WriteMore()

	stream.WriteString(c.Value)
	stream.WriteObjectField("refersTo")
	stream.WriteMore()

	c.RefersTo.marshalJSON(stream)

	stream.WriteObjectEnd()
}

func (c *HasExtensions) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"extensions": false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "extensions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object hasExtensions", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *HasExtensions) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("extensions")
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

func (c *Referable) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"extensions": false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "extensions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object referable", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *Referable) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("extensions")
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteMore()

	stream.WriteString(c.IdShort)
	stream.WriteObjectField("displayName")
	stream.WriteMore()

	c.DisplayName.marshalJSON(stream)
	stream.WriteObjectField("category")
	stream.WriteMore()

	stream.WriteString(c.Category)
	stream.WriteObjectField("description")
	stream.WriteMore()

	c.Description.marshalJSON(stream)

	stream.WriteObjectEnd()
}

func (c *Identifiable) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"extensions": false,
		"id":         false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "extensions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "id":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Id = iter.ReadString()
			isThere["id"] = true
		case "administration":
			myobj := &AdministrativeInformation{}
			myobj.unmarshalJSON(iter)
			c.Administration = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object identifiable", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *Identifiable) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("extensions")
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteMore()

	stream.WriteString(c.IdShort)
	stream.WriteObjectField("displayName")
	stream.WriteMore()

	c.DisplayName.marshalJSON(stream)
	stream.WriteObjectField("category")
	stream.WriteMore()

	stream.WriteString(c.Category)
	stream.WriteObjectField("description")
	stream.WriteMore()

	c.Description.marshalJSON(stream)
	stream.WriteObjectField("id")
	stream.WriteMore()

	stream.WriteString(c.Id)
	stream.WriteObjectField("administration")
	stream.WriteMore()

	c.Administration.marshalJSON(stream)

	stream.WriteObjectEnd()
}

func (e ModelingKind) unmarshalJSON(iter *json.Iterator) {
	if next := iter.WhatIsNext(); next != json.StringValue {
		iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
	}
	raw := iter.ReadString()
	if v, ok := ModelingKind_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", v))
	} else {
		e = v
	}
}

func (e ModelingKind) marshalJSON(stream *json.Stream) {
	v := ModelingKind_name[e]
	stream.WriteString(v)
}

func (c *HasKind) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object hasKind", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *HasKind) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("kind")
	c.Kind.marshalJSON(stream)

	stream.WriteObjectEnd()
}

func (c *HasDataSpecification) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object hasDataSpecification", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *HasDataSpecification) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("dataSpecifications")
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

func (c *AdministrativeInformation) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "version":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Version = iter.ReadString()
		case "revision":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Revision = iter.ReadString()
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object administrativeInformation", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *AdministrativeInformation) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("dataSpecifications")
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("version")
	stream.WriteMore()

	stream.WriteString(c.Version)
	stream.WriteObjectField("revision")
	stream.WriteMore()

	stream.WriteString(c.Revision)

	stream.WriteObjectEnd()
}

func (c *Constraint) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object constraint", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *Constraint) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectEnd()
}

func (c *Qualifiable) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"qualifiers": false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "qualifiers":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object qualifiable", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *Qualifiable) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("qualifiers")
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

func (c *Qualifier) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"type":      false,
		"valueType": false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "type":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Type = iter.ReadString()
			isThere["type"] = true
		case "valueType":
			var myenum DataTypeDef
			myenum.unmarshalJSON(iter)
			c.ValueType = &myenum
			isThere["valueType"] = true
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Value = iter.ReadString()
		case "valueID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.ValueId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object qualifier", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *Qualifier) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("type")
	stream.WriteMore()

	stream.WriteString(c.Type)
	stream.WriteObjectField("valueType")
	stream.WriteMore()

	c.ValueType.marshalJSON(stream)
	stream.WriteObjectField("value")
	stream.WriteMore()

	stream.WriteString(c.Value)
	stream.WriteObjectField("valueID")
	stream.WriteMore()

	c.ValueId.marshalJSON(stream)

	stream.WriteObjectEnd()
}

func (c *Formula) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dependsOn": false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dependsOn":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DependsOn = append(c.DependsOn, *myobj)
			}
			isThere["dependsOn"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object formula", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *Formula) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("dependsOn")
	stream.WriteArrayStart()
	for i, k := range c.DependsOn {
		k.marshalJSON(stream)
		if i < len(c.DependsOn)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

func (c *AssetAdministrationShell) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"id":                 false,
		"assetInformation":   false,
		"submodels":          false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "id":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Id = iter.ReadString()
			isThere["id"] = true
		case "administration":
			myobj := &AdministrativeInformation{}
			myobj.unmarshalJSON(iter)
			c.Administration = myobj
		case "derivedFrom":
		case "assetInformation":
			myobj := &AssetInformation{}
			myobj.unmarshalJSON(iter)
			isThere["assetInformation"] = true
			c.AssetInformation = myobj
		case "submodels":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
			}
			isThere["submodels"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object assetAdministrationShell", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *AssetAdministrationShell) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("dataSpecifications")
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteMore()

	stream.WriteString(c.IdShort)
	stream.WriteObjectField("displayName")
	stream.WriteMore()

	c.DisplayName.marshalJSON(stream)
	stream.WriteObjectField("category")
	stream.WriteMore()

	stream.WriteString(c.Category)
	stream.WriteObjectField("description")
	stream.WriteMore()

	c.Description.marshalJSON(stream)
	stream.WriteObjectField("id")
	stream.WriteMore()

	stream.WriteString(c.Id)
	stream.WriteObjectField("administration")
	stream.WriteMore()

	c.Administration.marshalJSON(stream)
	stream.WriteObjectField("derivedFrom")
	stream.WriteMore()

	stream.WriteObjectField("assetInformation")
	stream.WriteMore()

	c.AssetInformation.marshalJSON(stream)
	stream.WriteObjectField("submodels")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Submodels {
		k.marshalJSON(stream)
		if i < len(c.Submodels)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

func (c *AssetInformation) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"assetKind": false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "assetKind":
			var myenum AssetKind
			myenum.unmarshalJSON(iter)
			c.AssetKind = &myenum
			isThere["assetKind"] = true
		case "globalAssetID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.GlobalAssetId = myobj
		case "specificAssetID":
			myobj := &IdentifierKeyValuePair{}
			myobj.unmarshalJSON(iter)
			c.SpecificAssetId = myobj
		case "defaultThumbnail":
			myobj := &File{}
			myobj.unmarshalJSON(iter)
			c.DefaultThumbnail = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object assetInformation", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *AssetInformation) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("assetKind")
	c.AssetKind.marshalJSON(stream)
	stream.WriteObjectField("globalAssetID")
	stream.WriteMore()

	c.GlobalAssetId.marshalJSON(stream)
	stream.WriteObjectField("specificAssetID")
	stream.WriteMore()

	c.SpecificAssetId.marshalJSON(stream)
	stream.WriteObjectField("defaultThumbnail")
	stream.WriteMore()

	c.DefaultThumbnail.marshalJSON(stream)

	stream.WriteObjectEnd()
}

func (e AssetKind) unmarshalJSON(iter *json.Iterator) {
	if next := iter.WhatIsNext(); next != json.StringValue {
		iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
	}
	raw := iter.ReadString()
	if v, ok := AssetKind_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", v))
	} else {
		e = v
	}
}

func (e AssetKind) marshalJSON(stream *json.Stream) {
	v := AssetKind_name[e]
	stream.WriteString(v)
}

func (c *IdentifierKeyValuePair) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"key":   false,
		"value": false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "key":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Key = iter.ReadString()
			isThere["key"] = true
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Value = iter.ReadString()
			isThere["value"] = true
		case "externalSubjectID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.ExternalSubjectId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object identifierKeyValuePair", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *IdentifierKeyValuePair) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("key")
	stream.WriteMore()

	stream.WriteString(c.Key)
	stream.WriteObjectField("value")
	stream.WriteMore()

	stream.WriteString(c.Value)
	stream.WriteObjectField("externalSubjectID")
	stream.WriteMore()

	c.ExternalSubjectId.marshalJSON(stream)

	stream.WriteObjectEnd()
}

func (c *Submodel) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"qualifiers":         false,
		"extensions":         false,
		"id":                 false,
		"submodelElements":   false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "extensions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "id":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Id = iter.ReadString()
			isThere["id"] = true
		case "administration":
			myobj := &AdministrativeInformation{}
			myobj.unmarshalJSON(iter)
			c.Administration = myobj
		case "submodelElements":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &SubmodelElement{}
				myobj.unmarshalJSON(iter)
				c.SubmodelElements = append(c.SubmodelElements, *myobj)
			}
			isThere["submodelElements"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object submodel", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *Submodel) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("dataSpecifications")
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("kind")
	stream.WriteMore()

	c.Kind.marshalJSON(stream)
	stream.WriteObjectField("semanticID")
	stream.WriteMore()

	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("qualifiers")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteMore()

	stream.WriteString(c.IdShort)
	stream.WriteObjectField("displayName")
	stream.WriteMore()

	c.DisplayName.marshalJSON(stream)
	stream.WriteObjectField("category")
	stream.WriteMore()

	stream.WriteString(c.Category)
	stream.WriteObjectField("description")
	stream.WriteMore()

	c.Description.marshalJSON(stream)
	stream.WriteObjectField("id")
	stream.WriteMore()

	stream.WriteString(c.Id)
	stream.WriteObjectField("administration")
	stream.WriteMore()

	c.Administration.marshalJSON(stream)
	stream.WriteObjectField("submodelElements")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.SubmodelElements {
		k.marshalJSON(stream)
		if i < len(c.SubmodelElements)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

func (c *SubmodelElement) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object submodelElement", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *SubmodelElement) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("dataSpecifications")
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteMore()

	stream.WriteString(c.IdShort)
	stream.WriteObjectField("displayName")
	stream.WriteMore()

	c.DisplayName.marshalJSON(stream)
	stream.WriteObjectField("category")
	stream.WriteMore()

	stream.WriteString(c.Category)
	stream.WriteObjectField("description")
	stream.WriteMore()

	c.Description.marshalJSON(stream)
	stream.WriteObjectField("kind")
	stream.WriteMore()

	c.Kind.marshalJSON(stream)
	stream.WriteObjectField("semanticID")
	stream.WriteMore()

	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("qualifiers")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

func (c *RelationshipElement) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"first":              false,
		"second":             false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "first":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			isThere["first"] = true
			c.First = myobj
		case "second":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			isThere["second"] = true
			c.Second = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object relationshipElement", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *RelationshipElement) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("dataSpecifications")
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteMore()

	stream.WriteString(c.IdShort)
	stream.WriteObjectField("displayName")
	stream.WriteMore()

	c.DisplayName.marshalJSON(stream)
	stream.WriteObjectField("category")
	stream.WriteMore()

	stream.WriteString(c.Category)
	stream.WriteObjectField("description")
	stream.WriteMore()

	c.Description.marshalJSON(stream)
	stream.WriteObjectField("kind")
	stream.WriteMore()

	c.Kind.marshalJSON(stream)
	stream.WriteObjectField("semanticID")
	stream.WriteMore()

	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("qualifiers")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("first")
	stream.WriteMore()

	c.First.marshalJSON(stream)
	stream.WriteObjectField("second")
	stream.WriteMore()

	c.Second.marshalJSON(stream)

	stream.WriteObjectEnd()
}

func (c *SubmodelElementList) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications":        false,
		"extensions":                false,
		"qualifiers":                false,
		"submodelElementTypeValues": false,
		"values":                    false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "submodelElementTypeValues":
			var myenum SubmodelElements
			myenum.unmarshalJSON(iter)
			c.SubmodelElementTypeValues = &myenum
			isThere["submodelElementTypeValues"] = true
		case "values":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &SubmodelElement{}
				myobj.unmarshalJSON(iter)
				c.Values = append(c.Values, *myobj)
			}
			isThere["values"] = true
		case "semanticIDValues":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticIdValues = myobj
		case "valueTypeValues":
			var myenum DataTypeDef
			myenum.unmarshalJSON(iter)
			c.ValueTypeValues = &myenum
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object submodelElementList", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *SubmodelElementList) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("dataSpecifications")
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteMore()

	stream.WriteString(c.IdShort)
	stream.WriteObjectField("displayName")
	stream.WriteMore()

	c.DisplayName.marshalJSON(stream)
	stream.WriteObjectField("category")
	stream.WriteMore()

	stream.WriteString(c.Category)
	stream.WriteObjectField("description")
	stream.WriteMore()

	c.Description.marshalJSON(stream)
	stream.WriteObjectField("kind")
	stream.WriteMore()

	c.Kind.marshalJSON(stream)
	stream.WriteObjectField("semanticID")
	stream.WriteMore()

	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("qualifiers")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("submodelElementTypeValues")
	stream.WriteMore()

	c.SubmodelElementTypeValues.marshalJSON(stream)
	stream.WriteObjectField("values")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Values {
		k.marshalJSON(stream)
		if i < len(c.Values)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("semanticIDValues")
	stream.WriteMore()

	c.SemanticIdValues.marshalJSON(stream)
	stream.WriteObjectField("valueTypeValues")
	stream.WriteMore()

	c.ValueTypeValues.marshalJSON(stream)

	stream.WriteObjectEnd()
}

func (c *SubmodelElementStruct) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"values":             false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "values":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &SubmodelElement{}
				myobj.unmarshalJSON(iter)
				c.Values = append(c.Values, *myobj)
			}
			isThere["values"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object submodelElementStruct", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *SubmodelElementStruct) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("dataSpecifications")
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteMore()

	stream.WriteString(c.IdShort)
	stream.WriteObjectField("displayName")
	stream.WriteMore()

	c.DisplayName.marshalJSON(stream)
	stream.WriteObjectField("category")
	stream.WriteMore()

	stream.WriteString(c.Category)
	stream.WriteObjectField("description")
	stream.WriteMore()

	c.Description.marshalJSON(stream)
	stream.WriteObjectField("kind")
	stream.WriteMore()

	c.Kind.marshalJSON(stream)
	stream.WriteObjectField("semanticID")
	stream.WriteMore()

	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("qualifiers")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("values")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Values {
		k.marshalJSON(stream)
		if i < len(c.Values)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

func (c *DataElement) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object dataElement", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *DataElement) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("dataSpecifications")
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteMore()

	stream.WriteString(c.IdShort)
	stream.WriteObjectField("displayName")
	stream.WriteMore()

	c.DisplayName.marshalJSON(stream)
	stream.WriteObjectField("category")
	stream.WriteMore()

	stream.WriteString(c.Category)
	stream.WriteObjectField("description")
	stream.WriteMore()

	c.Description.marshalJSON(stream)
	stream.WriteObjectField("kind")
	stream.WriteMore()

	c.Kind.marshalJSON(stream)
	stream.WriteObjectField("semanticID")
	stream.WriteMore()

	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("qualifiers")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

func (c *Property) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"valueType":          false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "valueType":
			var myenum DataTypeDef
			myenum.unmarshalJSON(iter)
			c.ValueType = &myenum
			isThere["valueType"] = true
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Value = iter.ReadString()
		case "valueID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.ValueId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object property", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *Property) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("dataSpecifications")
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteMore()

	stream.WriteString(c.IdShort)
	stream.WriteObjectField("displayName")
	stream.WriteMore()

	c.DisplayName.marshalJSON(stream)
	stream.WriteObjectField("category")
	stream.WriteMore()

	stream.WriteString(c.Category)
	stream.WriteObjectField("description")
	stream.WriteMore()

	c.Description.marshalJSON(stream)
	stream.WriteObjectField("kind")
	stream.WriteMore()

	c.Kind.marshalJSON(stream)
	stream.WriteObjectField("semanticID")
	stream.WriteMore()

	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("qualifiers")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("valueType")
	stream.WriteMore()

	c.ValueType.marshalJSON(stream)
	stream.WriteObjectField("value")
	stream.WriteMore()

	stream.WriteString(c.Value)
	stream.WriteObjectField("valueID")
	stream.WriteMore()

	c.ValueId.marshalJSON(stream)

	stream.WriteObjectEnd()
}

func (c *MultiLanguageProperty) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "translatable":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Translatable = myobj
		case "valueID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.ValueId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object multiLanguageProperty", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *MultiLanguageProperty) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("dataSpecifications")
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteMore()

	stream.WriteString(c.IdShort)
	stream.WriteObjectField("displayName")
	stream.WriteMore()

	c.DisplayName.marshalJSON(stream)
	stream.WriteObjectField("category")
	stream.WriteMore()

	stream.WriteString(c.Category)
	stream.WriteObjectField("description")
	stream.WriteMore()

	c.Description.marshalJSON(stream)
	stream.WriteObjectField("kind")
	stream.WriteMore()

	c.Kind.marshalJSON(stream)
	stream.WriteObjectField("semanticID")
	stream.WriteMore()

	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("qualifiers")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("translatable")
	stream.WriteMore()

	c.Translatable.marshalJSON(stream)
	stream.WriteObjectField("valueID")
	stream.WriteMore()

	c.ValueId.marshalJSON(stream)

	stream.WriteObjectEnd()
}

func (c *Range) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"valueType":          false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "valueType":
			var myenum DataTypeDef
			myenum.unmarshalJSON(iter)
			c.ValueType = &myenum
			isThere["valueType"] = true
		case "min":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Min = iter.ReadString()
		case "max":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Max = iter.ReadString()
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object range", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *Range) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("dataSpecifications")
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteMore()

	stream.WriteString(c.IdShort)
	stream.WriteObjectField("displayName")
	stream.WriteMore()

	c.DisplayName.marshalJSON(stream)
	stream.WriteObjectField("category")
	stream.WriteMore()

	stream.WriteString(c.Category)
	stream.WriteObjectField("description")
	stream.WriteMore()

	c.Description.marshalJSON(stream)
	stream.WriteObjectField("kind")
	stream.WriteMore()

	c.Kind.marshalJSON(stream)
	stream.WriteObjectField("semanticID")
	stream.WriteMore()

	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("qualifiers")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("valueType")
	stream.WriteMore()

	c.ValueType.marshalJSON(stream)
	stream.WriteObjectField("min")
	stream.WriteMore()

	stream.WriteString(c.Min)
	stream.WriteObjectField("max")
	stream.WriteMore()

	stream.WriteString(c.Max)

	stream.WriteObjectEnd()
}

func (c *ReferenceElement) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "reference":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.Reference = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object referenceElement", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *ReferenceElement) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("dataSpecifications")
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteMore()

	stream.WriteString(c.IdShort)
	stream.WriteObjectField("displayName")
	stream.WriteMore()

	c.DisplayName.marshalJSON(stream)
	stream.WriteObjectField("category")
	stream.WriteMore()

	stream.WriteString(c.Category)
	stream.WriteObjectField("description")
	stream.WriteMore()

	c.Description.marshalJSON(stream)
	stream.WriteObjectField("kind")
	stream.WriteMore()

	c.Kind.marshalJSON(stream)
	stream.WriteObjectField("semanticID")
	stream.WriteMore()

	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("qualifiers")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("reference")
	stream.WriteMore()

	c.Reference.marshalJSON(stream)

	stream.WriteObjectEnd()
}

func (c *Blob) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"mimeType":           false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "mimeType":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.MimeType = iter.ReadString()
			isThere["mimeType"] = true
		case "content":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			c.Content = iter.ReadString()
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object blob", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *Blob) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("dataSpecifications")
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteMore()

	stream.WriteString(c.IdShort)
	stream.WriteObjectField("displayName")
	stream.WriteMore()

	c.DisplayName.marshalJSON(stream)
	stream.WriteObjectField("category")
	stream.WriteMore()

	stream.WriteString(c.Category)
	stream.WriteObjectField("description")
	stream.WriteMore()

	c.Description.marshalJSON(stream)
	stream.WriteObjectField("kind")
	stream.WriteMore()

	c.Kind.marshalJSON(stream)
	stream.WriteObjectField("semanticID")
	stream.WriteMore()

	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("qualifiers")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("mimeType")
	stream.WriteMore()

	stream.WriteString(c.MimeType)
	stream.WriteObjectField("content")
	stream.WriteMore()

	stream.WriteString(c.Content)

	stream.WriteObjectEnd()
}

func (c *File) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"mimeType":           false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "mimeType":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.MimeType = iter.ReadString()
			isThere["mimeType"] = true
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Value = iter.ReadString()
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object file", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *File) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("dataSpecifications")
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteMore()

	stream.WriteString(c.IdShort)
	stream.WriteObjectField("displayName")
	stream.WriteMore()

	c.DisplayName.marshalJSON(stream)
	stream.WriteObjectField("category")
	stream.WriteMore()

	stream.WriteString(c.Category)
	stream.WriteObjectField("description")
	stream.WriteMore()

	c.Description.marshalJSON(stream)
	stream.WriteObjectField("kind")
	stream.WriteMore()

	c.Kind.marshalJSON(stream)
	stream.WriteObjectField("semanticID")
	stream.WriteMore()

	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("qualifiers")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("mimeType")
	stream.WriteMore()

	stream.WriteString(c.MimeType)
	stream.WriteObjectField("value")
	stream.WriteMore()

	stream.WriteString(c.Value)

	stream.WriteObjectEnd()
}

func (c *AnnotatedRelationshipElement) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"first":              false,
		"second":             false,
		"annotation":         false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "first":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			isThere["first"] = true
			c.First = myobj
		case "second":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			isThere["second"] = true
			c.Second = myobj
		case "annotation":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &DataElement{}
				myobj.unmarshalJSON(iter)
				c.Annotation = append(c.Annotation, *myobj)
			}
			isThere["annotation"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object annotatedRelationshipElement", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *AnnotatedRelationshipElement) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("dataSpecifications")
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteMore()

	stream.WriteString(c.IdShort)
	stream.WriteObjectField("displayName")
	stream.WriteMore()

	c.DisplayName.marshalJSON(stream)
	stream.WriteObjectField("category")
	stream.WriteMore()

	stream.WriteString(c.Category)
	stream.WriteObjectField("description")
	stream.WriteMore()

	c.Description.marshalJSON(stream)
	stream.WriteObjectField("kind")
	stream.WriteMore()

	c.Kind.marshalJSON(stream)
	stream.WriteObjectField("semanticID")
	stream.WriteMore()

	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("qualifiers")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("first")
	stream.WriteMore()

	c.First.marshalJSON(stream)
	stream.WriteObjectField("second")
	stream.WriteMore()

	c.Second.marshalJSON(stream)
	stream.WriteObjectField("annotation")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Annotation {
		k.marshalJSON(stream)
		if i < len(c.Annotation)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

func (e EntityType) unmarshalJSON(iter *json.Iterator) {
	if next := iter.WhatIsNext(); next != json.StringValue {
		iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
	}
	raw := iter.ReadString()
	if v, ok := EntityType_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", v))
	} else {
		e = v
	}
}

func (e EntityType) marshalJSON(stream *json.Stream) {
	v := EntityType_name[e]
	stream.WriteString(v)
}

func (c *Entity) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"entityType":         false,
		"statements":         false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "entityType":
			var myenum EntityType
			myenum.unmarshalJSON(iter)
			c.EntityType = &myenum
			isThere["entityType"] = true
		case "statements":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &SubmodelElement{}
				myobj.unmarshalJSON(iter)
				c.Statements = append(c.Statements, *myobj)
			}
			isThere["statements"] = true
		case "globalAssetID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.GlobalAssetId = myobj
		case "specificAssetID":
			myobj := &IdentifierKeyValuePair{}
			myobj.unmarshalJSON(iter)
			c.SpecificAssetId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object entity", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *Entity) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("dataSpecifications")
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteMore()

	stream.WriteString(c.IdShort)
	stream.WriteObjectField("displayName")
	stream.WriteMore()

	c.DisplayName.marshalJSON(stream)
	stream.WriteObjectField("category")
	stream.WriteMore()

	stream.WriteString(c.Category)
	stream.WriteObjectField("description")
	stream.WriteMore()

	c.Description.marshalJSON(stream)
	stream.WriteObjectField("kind")
	stream.WriteMore()

	c.Kind.marshalJSON(stream)
	stream.WriteObjectField("semanticID")
	stream.WriteMore()

	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("qualifiers")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("entityType")
	stream.WriteMore()

	c.EntityType.marshalJSON(stream)
	stream.WriteObjectField("statements")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Statements {
		k.marshalJSON(stream)
		if i < len(c.Statements)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("globalAssetID")
	stream.WriteMore()

	c.GlobalAssetId.marshalJSON(stream)
	stream.WriteObjectField("specificAssetID")
	stream.WriteMore()

	c.SpecificAssetId.marshalJSON(stream)

	stream.WriteObjectEnd()
}

func (c *Event) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object event", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *Event) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("dataSpecifications")
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteMore()

	stream.WriteString(c.IdShort)
	stream.WriteObjectField("displayName")
	stream.WriteMore()

	c.DisplayName.marshalJSON(stream)
	stream.WriteObjectField("category")
	stream.WriteMore()

	stream.WriteString(c.Category)
	stream.WriteObjectField("description")
	stream.WriteMore()

	c.Description.marshalJSON(stream)
	stream.WriteObjectField("kind")
	stream.WriteMore()

	c.Kind.marshalJSON(stream)
	stream.WriteObjectField("semanticID")
	stream.WriteMore()

	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("qualifiers")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

func (c *BasicEvent) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"observed":           false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "observed":
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object basicEvent", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *BasicEvent) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("dataSpecifications")
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteMore()

	stream.WriteString(c.IdShort)
	stream.WriteObjectField("displayName")
	stream.WriteMore()

	c.DisplayName.marshalJSON(stream)
	stream.WriteObjectField("category")
	stream.WriteMore()

	stream.WriteString(c.Category)
	stream.WriteObjectField("description")
	stream.WriteMore()

	c.Description.marshalJSON(stream)
	stream.WriteObjectField("kind")
	stream.WriteMore()

	c.Kind.marshalJSON(stream)
	stream.WriteObjectField("semanticID")
	stream.WriteMore()

	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("qualifiers")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("observed")
	stream.WriteMore()

	stream.WriteObjectEnd()
}

func (c *Operation) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"inputVariables":     false,
		"outputVariables":    false,
		"inoutputVariables":  false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "inputVariables":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &OperationVariable{}
				myobj.unmarshalJSON(iter)
				c.InputVariables = append(c.InputVariables, *myobj)
			}
			isThere["inputVariables"] = true
		case "outputVariables":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &OperationVariable{}
				myobj.unmarshalJSON(iter)
				c.OutputVariables = append(c.OutputVariables, *myobj)
			}
			isThere["outputVariables"] = true
		case "inoutputVariables":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &OperationVariable{}
				myobj.unmarshalJSON(iter)
				c.InoutputVariables = append(c.InoutputVariables, *myobj)
			}
			isThere["inoutputVariables"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object operation", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *Operation) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("dataSpecifications")
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteMore()

	stream.WriteString(c.IdShort)
	stream.WriteObjectField("displayName")
	stream.WriteMore()

	c.DisplayName.marshalJSON(stream)
	stream.WriteObjectField("category")
	stream.WriteMore()

	stream.WriteString(c.Category)
	stream.WriteObjectField("description")
	stream.WriteMore()

	c.Description.marshalJSON(stream)
	stream.WriteObjectField("kind")
	stream.WriteMore()

	c.Kind.marshalJSON(stream)
	stream.WriteObjectField("semanticID")
	stream.WriteMore()

	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("qualifiers")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("inputVariables")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.InputVariables {
		k.marshalJSON(stream)
		if i < len(c.InputVariables)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("outputVariables")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.OutputVariables {
		k.marshalJSON(stream)
		if i < len(c.OutputVariables)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("inoutputVariables")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.InoutputVariables {
		k.marshalJSON(stream)
		if i < len(c.InoutputVariables)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

func (c *OperationVariable) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"value": false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "value":
			myobj := &SubmodelElement{}
			myobj.unmarshalJSON(iter)
			isThere["value"] = true
			c.Value = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object operationVariable", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *OperationVariable) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("value")
	c.Value.marshalJSON(stream)

	stream.WriteObjectEnd()
}

func (c *Capability) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object capability", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *Capability) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("dataSpecifications")
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteMore()

	stream.WriteString(c.IdShort)
	stream.WriteObjectField("displayName")
	stream.WriteMore()

	c.DisplayName.marshalJSON(stream)
	stream.WriteObjectField("category")
	stream.WriteMore()

	stream.WriteString(c.Category)
	stream.WriteObjectField("description")
	stream.WriteMore()

	c.Description.marshalJSON(stream)
	stream.WriteObjectField("kind")
	stream.WriteMore()

	c.Kind.marshalJSON(stream)
	stream.WriteObjectField("semanticID")
	stream.WriteMore()

	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("qualifiers")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

func (c *ConceptDescription) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"id":                 false,
		"isCaseOf":           false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "id":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Id = iter.ReadString()
			isThere["id"] = true
		case "administration":
			myobj := &AdministrativeInformation{}
			myobj.unmarshalJSON(iter)
			c.Administration = myobj
		case "isCaseOf":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.IsCaseOf = append(c.IsCaseOf, *myobj)
			}
			isThere["isCaseOf"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object conceptDescription", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *ConceptDescription) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("dataSpecifications")
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteMore()

	stream.WriteString(c.IdShort)
	stream.WriteObjectField("displayName")
	stream.WriteMore()

	c.DisplayName.marshalJSON(stream)
	stream.WriteObjectField("category")
	stream.WriteMore()

	stream.WriteString(c.Category)
	stream.WriteObjectField("description")
	stream.WriteMore()

	c.Description.marshalJSON(stream)
	stream.WriteObjectField("id")
	stream.WriteMore()

	stream.WriteString(c.Id)
	stream.WriteObjectField("administration")
	stream.WriteMore()

	c.Administration.marshalJSON(stream)
	stream.WriteObjectField("isCaseOf")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.IsCaseOf {
		k.marshalJSON(stream)
		if i < len(c.IsCaseOf)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

func (c *View) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"containedElements":  false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "containedElements":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
			}
			isThere["containedElements"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object view", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *View) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("dataSpecifications")
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteMore()

	stream.WriteString(c.IdShort)
	stream.WriteObjectField("displayName")
	stream.WriteMore()

	c.DisplayName.marshalJSON(stream)
	stream.WriteObjectField("category")
	stream.WriteMore()

	stream.WriteString(c.Category)
	stream.WriteObjectField("description")
	stream.WriteMore()

	c.Description.marshalJSON(stream)
	stream.WriteObjectField("semanticID")
	stream.WriteMore()

	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("containedElements")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.ContainedElements {
		k.marshalJSON(stream)
		if i < len(c.ContainedElements)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

func (c *Reference) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object reference", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *Reference) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectEnd()
}

func (c *GlobalReference) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"values": false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "values":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				if next := iter.WhatIsNext(); next != json.StringValue {
					iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
				}
				c.Values = iter.ReadString()
			}
			isThere["values"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object globalReference", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *GlobalReference) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("values")
	stream.WriteArrayStart()
	for i, k := range c.Values {
		k.marshalJSON(stream)
		if i < len(c.Values)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

func (c *ModelReference) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"keys": false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "keys":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Key{}
				myobj.unmarshalJSON(iter)
				c.Keys = append(c.Keys, *myobj)
			}
			isThere["keys"] = true
		case "referredSemanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.ReferredSemanticId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object modelReference", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *ModelReference) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("keys")
	stream.WriteArrayStart()
	for i, k := range c.Keys {
		k.marshalJSON(stream)
		if i < len(c.Keys)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("referredSemanticID")
	stream.WriteMore()

	c.ReferredSemanticId.marshalJSON(stream)

	stream.WriteObjectEnd()
}

func (c *Key) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"type":  false,
		"value": false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "type":
			var myenum KeyElements
			myenum.unmarshalJSON(iter)
			c.Type = &myenum
			isThere["type"] = true
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Value = iter.ReadString()
			isThere["value"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object key", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *Key) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("type")
	c.Type.marshalJSON(stream)
	stream.WriteObjectField("value")
	stream.WriteMore()

	stream.WriteString(c.Value)

	stream.WriteObjectEnd()
}

func (e IdentifiableElements) unmarshalJSON(iter *json.Iterator) {
	if next := iter.WhatIsNext(); next != json.StringValue {
		iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
	}
	raw := iter.ReadString()
	if v, ok := IdentifiableElements_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", v))
	} else {
		e = v
	}
}

func (e IdentifiableElements) marshalJSON(stream *json.Stream) {
	v := IdentifiableElements_name[e]
	stream.WriteString(v)
}

func (e ReferableElements) unmarshalJSON(iter *json.Iterator) {
	if next := iter.WhatIsNext(); next != json.StringValue {
		iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
	}
	raw := iter.ReadString()
	if v, ok := ReferableElements_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", v))
	} else {
		e = v
	}
}

func (e ReferableElements) marshalJSON(stream *json.Stream) {
	v := ReferableElements_name[e]
	stream.WriteString(v)
}

func (e KeyElements) unmarshalJSON(iter *json.Iterator) {
	if next := iter.WhatIsNext(); next != json.StringValue {
		iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
	}
	raw := iter.ReadString()
	if v, ok := KeyElements_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", v))
	} else {
		e = v
	}
}

func (e KeyElements) marshalJSON(stream *json.Stream) {
	v := KeyElements_name[e]
	stream.WriteString(v)
}

func (e SubmodelElements) unmarshalJSON(iter *json.Iterator) {
	if next := iter.WhatIsNext(); next != json.StringValue {
		iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
	}
	raw := iter.ReadString()
	if v, ok := SubmodelElements_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", v))
	} else {
		e = v
	}
}

func (e SubmodelElements) marshalJSON(stream *json.Stream) {
	v := SubmodelElements_name[e]
	stream.WriteString(v)
}

func (e BuildInListTypes) unmarshalJSON(iter *json.Iterator) {
	if next := iter.WhatIsNext(); next != json.StringValue {
		iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
	}
	raw := iter.ReadString()
	if v, ok := BuildInListTypes_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", v))
	} else {
		e = v
	}
}

func (e BuildInListTypes) marshalJSON(stream *json.Stream) {
	v := BuildInListTypes_name[e]
	stream.WriteString(v)
}

func (e DecimalBuildInTypes) unmarshalJSON(iter *json.Iterator) {
	if next := iter.WhatIsNext(); next != json.StringValue {
		iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
	}
	raw := iter.ReadString()
	if v, ok := DecimalBuildInTypes_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", v))
	} else {
		e = v
	}
}

func (e DecimalBuildInTypes) marshalJSON(stream *json.Stream) {
	v := DecimalBuildInTypes_name[e]
	stream.WriteString(v)
}

func (e DurationBuildInTypes) unmarshalJSON(iter *json.Iterator) {
	if next := iter.WhatIsNext(); next != json.StringValue {
		iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
	}
	raw := iter.ReadString()
	if v, ok := DurationBuildInTypes_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", v))
	} else {
		e = v
	}
}

func (e DurationBuildInTypes) marshalJSON(stream *json.Stream) {
	v := DurationBuildInTypes_name[e]
	stream.WriteString(v)
}

func (e PrimitiveTypes) unmarshalJSON(iter *json.Iterator) {
	if next := iter.WhatIsNext(); next != json.StringValue {
		iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
	}
	raw := iter.ReadString()
	if v, ok := PrimitiveTypes_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", v))
	} else {
		e = v
	}
}

func (e PrimitiveTypes) marshalJSON(stream *json.Stream) {
	v := PrimitiveTypes_name[e]
	stream.WriteString(v)
}

func (e StringBuildInTypes) unmarshalJSON(iter *json.Iterator) {
	if next := iter.WhatIsNext(); next != json.StringValue {
		iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
	}
	raw := iter.ReadString()
	if v, ok := StringBuildInTypes_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", v))
	} else {
		e = v
	}
}

func (e StringBuildInTypes) marshalJSON(stream *json.Stream) {
	v := StringBuildInTypes_name[e]
	stream.WriteString(v)
}

func (e DataTypeDef) unmarshalJSON(iter *json.Iterator) {
	if next := iter.WhatIsNext(); next != json.StringValue {
		iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
	}
	raw := iter.ReadString()
	if v, ok := DataTypeDef_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", v))
	} else {
		e = v
	}
}

func (e DataTypeDef) marshalJSON(stream *json.Stream) {
	v := DataTypeDef_name[e]
	stream.WriteString(v)
}

func (c *LangStringSet) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object langStringSet", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *LangStringSet) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectEnd()
}

func (c *DataSpecificationContent) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object dataSpecificationContent", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *DataSpecificationContent) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectEnd()
}

func (e DataTypeIec61360) unmarshalJSON(iter *json.Iterator) {
	if next := iter.WhatIsNext(); next != json.StringValue {
		iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
	}
	raw := iter.ReadString()
	if v, ok := DataTypeIec61360_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", v))
	} else {
		e = v
	}
}

func (e DataTypeIec61360) marshalJSON(stream *json.Stream) {
	v := DataTypeIec61360_name[e]
	stream.WriteString(v)
}

func (e LevelType) unmarshalJSON(iter *json.Iterator) {
	if next := iter.WhatIsNext(); next != json.StringValue {
		iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
	}
	raw := iter.ReadString()
	if v, ok := LevelType_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", v))
	} else {
		e = v
	}
}

func (e LevelType) marshalJSON(stream *json.Stream) {
	v := LevelType_name[e]
	stream.WriteString(v)
}

func (c *ValueReferencePair) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"value":   false,
		"valueID": false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Value = iter.ReadString()
			isThere["value"] = true
		case "valueID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			isThere["valueID"] = true
			c.ValueId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object valueReferencePair", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *ValueReferencePair) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("value")
	stream.WriteString(c.Value)
	stream.WriteObjectField("valueID")
	stream.WriteMore()

	c.ValueId.marshalJSON(stream)

	stream.WriteObjectEnd()
}

func (c *ValueList) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"valueReferencePairs": false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "valueReferencePairs":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ValueReferencePair{}
				myobj.unmarshalJSON(iter)
				c.ValueReferencePairs = append(c.ValueReferencePairs, *myobj)
			}
			isThere["valueReferencePairs"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object valueList", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *ValueList) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("valueReferencePairs")
	stream.WriteArrayStart()
	for i, k := range c.ValueReferencePairs {
		k.marshalJSON(stream)
		if i < len(c.ValueReferencePairs)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

func (c *DataSpecificationIec61360) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "preferredName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.PreferredName = myobj
		case "shortName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.ShortName = myobj
		case "unit":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Unit = iter.ReadString()
		case "unitID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.UnitId = myobj
		case "sourceOfDefinition":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.SourceOfDefinition = iter.ReadString()
		case "symbol":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Symbol = iter.ReadString()
		case "dataType":
			var myenum DataTypeIec61360
			myenum.unmarshalJSON(iter)
			c.DataType = &myenum
		case "definition":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Definition = myobj
		case "valueFormat":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.ValueFormat = iter.ReadString()
		case "valueList":
			myobj := &ValueList{}
			myobj.unmarshalJSON(iter)
			c.ValueList = myobj
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Value = iter.ReadString()
		case "valueID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.ValueId = myobj
		case "levelType":
			var myenum LevelType
			myenum.unmarshalJSON(iter)
			c.LevelType = &myenum
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object dataSpecificationIec61360", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *DataSpecificationIec61360) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("preferredName")
	c.PreferredName.marshalJSON(stream)
	stream.WriteObjectField("shortName")
	stream.WriteMore()

	c.ShortName.marshalJSON(stream)
	stream.WriteObjectField("unit")
	stream.WriteMore()

	stream.WriteString(c.Unit)
	stream.WriteObjectField("unitID")
	stream.WriteMore()

	c.UnitId.marshalJSON(stream)
	stream.WriteObjectField("sourceOfDefinition")
	stream.WriteMore()

	stream.WriteString(c.SourceOfDefinition)
	stream.WriteObjectField("symbol")
	stream.WriteMore()

	stream.WriteString(c.Symbol)
	stream.WriteObjectField("dataType")
	stream.WriteMore()

	c.DataType.marshalJSON(stream)
	stream.WriteObjectField("definition")
	stream.WriteMore()

	c.Definition.marshalJSON(stream)
	stream.WriteObjectField("valueFormat")
	stream.WriteMore()

	stream.WriteString(c.ValueFormat)
	stream.WriteObjectField("valueList")
	stream.WriteMore()

	c.ValueList.marshalJSON(stream)
	stream.WriteObjectField("value")
	stream.WriteMore()

	stream.WriteString(c.Value)
	stream.WriteObjectField("valueID")
	stream.WriteMore()

	c.ValueId.marshalJSON(stream)
	stream.WriteObjectField("levelType")
	stream.WriteMore()

	c.LevelType.marshalJSON(stream)

	stream.WriteObjectEnd()
}

func (c *DataSpecificationPhysicalUnit) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "unitName":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.UnitName = iter.ReadString()
		case "unitSymbol":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.UnitSymbol = iter.ReadString()
		case "definition":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Definition = myobj
		case "siNotation":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.SiNotation = iter.ReadString()
		case "dinNotation":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.DinNotation = iter.ReadString()
		case "eceName":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.EceName = iter.ReadString()
		case "eceCode":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.EceCode = iter.ReadString()
		case "nistName":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.NistName = iter.ReadString()
		case "sourceOfDefinition":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.SourceOfDefinition = iter.ReadString()
		case "conversionFactor":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.ConversionFactor = iter.ReadString()
		case "registrationAuthorityID":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.RegistrationAuthorityId = iter.ReadString()
		case "supplier":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Supplier = iter.ReadString()
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object dataSpecificationPhysicalUnit", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *DataSpecificationPhysicalUnit) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("unitName")
	stream.WriteString(c.UnitName)
	stream.WriteObjectField("unitSymbol")
	stream.WriteMore()

	stream.WriteString(c.UnitSymbol)
	stream.WriteObjectField("definition")
	stream.WriteMore()

	c.Definition.marshalJSON(stream)
	stream.WriteObjectField("siNotation")
	stream.WriteMore()

	stream.WriteString(c.SiNotation)
	stream.WriteObjectField("dinNotation")
	stream.WriteMore()

	stream.WriteString(c.DinNotation)
	stream.WriteObjectField("eceName")
	stream.WriteMore()

	stream.WriteString(c.EceName)
	stream.WriteObjectField("eceCode")
	stream.WriteMore()

	stream.WriteString(c.EceCode)
	stream.WriteObjectField("nistName")
	stream.WriteMore()

	stream.WriteString(c.NistName)
	stream.WriteObjectField("sourceOfDefinition")
	stream.WriteMore()

	stream.WriteString(c.SourceOfDefinition)
	stream.WriteObjectField("conversionFactor")
	stream.WriteMore()

	stream.WriteString(c.ConversionFactor)
	stream.WriteObjectField("registrationAuthorityID")
	stream.WriteMore()

	stream.WriteString(c.RegistrationAuthorityId)
	stream.WriteObjectField("supplier")
	stream.WriteMore()

	stream.WriteString(c.Supplier)

	stream.WriteObjectEnd()
}

func (c *Environment) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"assetAdministrationShells": false,
		"submodels":                 false,
		"conceptDescriptions":       false,
	}

	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "assetAdministrationShells":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &AssetAdministrationShell{}
				myobj.unmarshalJSON(iter)
				c.AssetAdministrationShells = append(c.AssetAdministrationShells, *myobj)
			}
			isThere["assetAdministrationShells"] = true
		case "submodels":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Submodel{}
				myobj.unmarshalJSON(iter)
				c.Submodels = append(c.Submodels, *myobj)
			}
			isThere["submodels"] = true
		case "conceptDescriptions":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ConceptDescription{}
				myobj.unmarshalJSON(iter)
				c.ConceptDescriptions = append(c.ConceptDescriptions, *myobj)
			}
			isThere["conceptDescriptions"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object environment", f))
		}
	}

	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

func (c *Environment) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()
	stream.WriteObjectField("assetAdministrationShells")
	stream.WriteArrayStart()
	for i, k := range c.AssetAdministrationShells {
		k.marshalJSON(stream)
		if i < len(c.AssetAdministrationShells)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("submodels")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.Submodels {
		k.marshalJSON(stream)
		if i < len(c.Submodels)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("conceptDescriptions")
	stream.WriteMore()

	stream.WriteArrayStart()
	for i, k := range c.ConceptDescriptions {
		k.marshalJSON(stream)
		if i < len(c.ConceptDescriptions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}
