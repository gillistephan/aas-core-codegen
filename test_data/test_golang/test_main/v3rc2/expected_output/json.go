// Code generated by aas-core-codegen. DO NOT EDIT.

package aascore

import (
	"fmt"
	"io"
	"reflect"

	json "github.com/json-iterator/go"
)

const (
	NonNilPointerError = "v must be a pointer and non nil"
)

// AasCoreMarshaler is the interface implemented by all types of the meta-model
// that can marshal themselves into a valid JSON.
type AasCoreMarshaler interface {
	marshalJSON(stream *json.Stream)
}

// AasCoreUnmarshaler is the interface implemented by all types of the meta-model
// that can unmarshal a JSON description of themselves.
type AasCoreUnmarshaler interface {
	unmarshalJSON(iter *json.Iterator)
}

// Encoder writes JSON values to an output stream.
type Encoder struct {
	stream *json.Stream
}

// Decoder reads and decodes JSON values from an input stream.
type Decoder struct {
	iter *json.Iterator
}

// isNonNilPointer checks, if a given value v is a pointer or not nil
func isNonNilPointer(v interface{}) bool {
	rv := reflect.ValueOf(v)
	if rv.Kind() != reflect.Ptr || rv.IsNil() {
		return false
	}
	return true
}

// Unmarshal parses the JSON-encoded data and stores
// the result in the value pointed by v. If v is nil or not a pointer
// Unmarshal returns an error. If v implements the AasCoreUnmarshaler interface
// of the AAS-Meta-Model, data will be decoded according to the specifications of
// the meta-model. If not, Unmarshal will decode the data in complience with
// the standard library. It can be used as a drop-in replacement
// of the encoding/json standard library.
func Unmarshal(data []byte, v interface{}) error {
	if isNonNilPointer(v) {
		return fmt.Errorf(NonNilPointerError)
	}

	if u, ok := v.(AasCoreUnmarshaler); !ok {
		return json.Unmarshal(data, data)
	} else {
		iter := json.ParseBytes(json.ConfigDefault, data)
		dec := &Decoder{iter}
		err := dec.Decode(u)
		return err
	}
}

// Marshal traverses the value v recursively. If v implements the AasCoreMarshaler
// interface and is not a nil pointer, Marshal calls the marshalJSON method to encode
// v according to the specifications of the AAS-Meta-Model. If v does not implement the
// AasCoreMarshaler interface, Marshal will decode the data in complience with standard
// library. It can be used as a drop-in replacement of the encoding/json standard library.
func Marshal(v interface{}) ([]byte, error) {
	if m, ok := v.(AasCoreMarshaler); !ok {
		return json.Marshal(v)
	} else {
		stream := json.ConfigDefault.BorrowStream(nil)
		enc := &Encoder{stream}
		err := enc.Encode(m)
		if err != nil {
			return nil, err
		}
		bytes := enc.stream.Buffer()
		return bytes, nil
	}
}

// NewDecoder returns a new Decoder that reads from r.
// Bs is the internal buffer size set in the NewDecoder.
func NewDecoder(bs int, r io.Reader) *Decoder {
	iter := json.Parse(json.ConfigCompatibleWithStandardLibrary, r, bs)
	return &Decoder{iter}
}

// NewEcoder returns a new Encoder that writes to w.
// Bs is the internal buffer size set in the NewEncoder.
func NewEncoder(bs int, w io.Writer) *Encoder {
	stream := json.NewStream(json.ConfigCompatibleWithStandardLibrary, w, bs)
	return &Encoder{stream}
}

// Decode reads the next encoded value from its input and
// writes it in the value pointed to by v. If v implements
// the AasCoreUnmarshaler interface, v will be decoded according
// to the specifications of the AAS-Meta-Model. If not,
// Decode will decode the data in complience with the standard library.
// It can be used as a drop-in replacement of the encoding/json standard library.
func (d *Decoder) Decode(v interface{}) error {
	if isNonNilPointer(v) {
		return fmt.Errorf(NonNilPointerError)
	}
	if u, ok := v.(AasCoreUnmarshaler); !ok {
		d.iter.ReadVal(v)
	} else {
		u.unmarshalJSON(d.iter)
	}
	err := d.iter.Error
	if err == io.EOF {
		return nil
	}
	return d.iter.Error
}

// Encode writes the encoding of v to the input stream v.
// If v implements the AasCoreMarshaler interface and v is
// not a nil pointer, Encode calls the marshalJSON method recursively
// and encodes the data according to the specifications of the AAS-Meta-Model.
// If v does not implement AasCoreMarshaler interface, Encode will encode the
// data in complience with the standard library. It can be used as a drop-in
// replacement of the encoding/json standard library.
func (e *Encoder) Encode(v interface{}) error {
	if m, ok := v.(AasCoreMarshaler); !ok {
		e.stream.WriteVal(v)
	} else {
		m.marshalJSON(e.stream)
	}
	e.stream.WriteRaw("\n")
	e.stream.Flush()
	return e.stream.Error
}

// unmarshalJSON implements the Unmarshaler interface for HasSemantics
func (c *HasSemantics) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object hasSemantics", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for HasSemantics
func (c *HasSemantics) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Extension
func (c *Extension) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"name": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "name":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Name = iter.ReadString()
			isThere["name"] = true
		case "valueType":
			var myenum DataTypeDef
			myenum.unmarshalJSON(iter)
			c.ValueType = &myenum
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Value = iter.ReadString()
		case "refersTo":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.RefersTo = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object extension", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Extension
func (c *Extension) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("name")
	stream.WriteString(c.Name)
	stream.WriteMore()

	stream.WriteObjectField("valueType")
	c.ValueType.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("value")
	stream.WriteString(c.Value)
	stream.WriteMore()

	stream.WriteObjectField("refersTo")
	c.RefersTo.marshalJSON(stream)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for HasExtensions
func (c *HasExtensions) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"extensions": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "extensions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object hasExtensions", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for HasExtensions
func (c *HasExtensions) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Referable
func (c *Referable) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"extensions": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "extensions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object referable", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Referable
func (c *Referable) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteString(c.IdShort)
	stream.WriteMore()

	stream.WriteObjectField("displayName")
	c.DisplayName.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("category")
	stream.WriteString(c.Category)
	stream.WriteMore()

	stream.WriteObjectField("description")
	c.Description.marshalJSON(stream)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Identifiable
func (c *Identifiable) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"extensions": false,
		"id":         false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "extensions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "id":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Id = iter.ReadString()
			isThere["id"] = true
		case "administration":
			myobj := &AdministrativeInformation{}
			myobj.unmarshalJSON(iter)
			c.Administration = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object identifiable", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Identifiable
func (c *Identifiable) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("idShort")
	stream.WriteString(c.IdShort)
	stream.WriteMore()

	stream.WriteObjectField("displayName")
	c.DisplayName.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("category")
	stream.WriteString(c.Category)
	stream.WriteMore()

	stream.WriteObjectField("description")
	c.Description.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("id")
	stream.WriteString(c.Id)
	stream.WriteMore()

	stream.WriteObjectField("administration")
	c.Administration.marshalJSON(stream)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for ModelingKind
func (e ModelingKind) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := ModelingKind_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for ModelingKind
func (e ModelingKind) marshalJSON(stream *json.Stream) {
	stream.WriteString(ModelingKind_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for HasKind
func (c *HasKind) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object hasKind", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for HasKind
func (c *HasKind) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("kind")
	c.Kind.marshalJSON(stream)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for HasDataSpecification
func (c *HasDataSpecification) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object hasDataSpecification", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for HasDataSpecification
func (c *HasDataSpecification) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for AdministrativeInformation
func (c *AdministrativeInformation) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "version":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Version = iter.ReadString()
		case "revision":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Revision = iter.ReadString()
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object administrativeInformation", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for AdministrativeInformation
func (c *AdministrativeInformation) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("version")
	stream.WriteString(c.Version)
	stream.WriteMore()

	stream.WriteObjectField("revision")
	stream.WriteString(c.Revision)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Constraint
func (c *Constraint) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object constraint", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Constraint
func (c *Constraint) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Qualifiable
func (c *Qualifiable) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"qualifiers": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object qualifiable", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Qualifiable
func (c *Qualifiable) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Qualifier
func (c *Qualifier) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"type":      false,
		"valueType": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "type":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Type = iter.ReadString()
			isThere["type"] = true
		case "valueType":
			var myenum DataTypeDef
			myenum.unmarshalJSON(iter)
			c.ValueType = &myenum
			isThere["valueType"] = true
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Value = iter.ReadString()
		case "valueID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.ValueId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object qualifier", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Qualifier
func (c *Qualifier) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("type")
	stream.WriteString(c.Type)
	stream.WriteMore()

	stream.WriteObjectField("valueType")
	c.ValueType.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("value")
	stream.WriteString(c.Value)
	stream.WriteMore()

	stream.WriteObjectField("valueID")
	c.ValueId.marshalJSON(stream)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Formula
func (c *Formula) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dependsOn": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dependsOn":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DependsOn = append(c.DependsOn, *myobj)
			}
			isThere["dependsOn"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object formula", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Formula
func (c *Formula) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dependsOn")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DependsOn {
		k.marshalJSON(stream)
		if i < len(c.DependsOn)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for AssetAdministrationShell
func (c *AssetAdministrationShell) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"id":                 false,
		"assetInformation":   false,
		"submodels":          false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "id":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Id = iter.ReadString()
			isThere["id"] = true
		case "administration":
			myobj := &AdministrativeInformation{}
			myobj.unmarshalJSON(iter)
			c.Administration = myobj
		case "derivedFrom":
		case "assetInformation":
			myobj := &AssetInformation{}
			myobj.unmarshalJSON(iter)
			isThere["assetInformation"] = true
			c.AssetInformation = myobj
		case "submodels":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
			}
			isThere["submodels"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object assetAdministrationShell", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for AssetAdministrationShell
func (c *AssetAdministrationShell) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("idShort")
	stream.WriteString(c.IdShort)
	stream.WriteMore()

	stream.WriteObjectField("displayName")
	c.DisplayName.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("category")
	stream.WriteString(c.Category)
	stream.WriteMore()

	stream.WriteObjectField("description")
	c.Description.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("id")
	stream.WriteString(c.Id)
	stream.WriteMore()

	stream.WriteObjectField("administration")
	c.Administration.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("derivedFrom")
	stream.WriteMore()

	stream.WriteObjectField("assetInformation")
	c.AssetInformation.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("submodels")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Submodels {
		k.marshalJSON(stream)
		if i < len(c.Submodels)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for AssetInformation
func (c *AssetInformation) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"assetKind": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "assetKind":
			var myenum AssetKind
			myenum.unmarshalJSON(iter)
			c.AssetKind = &myenum
			isThere["assetKind"] = true
		case "globalAssetID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.GlobalAssetId = myobj
		case "specificAssetID":
			myobj := &IdentifierKeyValuePair{}
			myobj.unmarshalJSON(iter)
			c.SpecificAssetId = myobj
		case "defaultThumbnail":
			myobj := &File{}
			myobj.unmarshalJSON(iter)
			c.DefaultThumbnail = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object assetInformation", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for AssetInformation
func (c *AssetInformation) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("assetKind")
	c.AssetKind.marshalJSON(stream)
	stream.WriteObjectField("globalAssetID")
	c.GlobalAssetId.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("specificAssetID")
	c.SpecificAssetId.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("defaultThumbnail")
	c.DefaultThumbnail.marshalJSON(stream)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for AssetKind
func (e AssetKind) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := AssetKind_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for AssetKind
func (e AssetKind) marshalJSON(stream *json.Stream) {
	stream.WriteString(AssetKind_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for IdentifierKeyValuePair
func (c *IdentifierKeyValuePair) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"key":   false,
		"value": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "key":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Key = iter.ReadString()
			isThere["key"] = true
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Value = iter.ReadString()
			isThere["value"] = true
		case "externalSubjectID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.ExternalSubjectId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object identifierKeyValuePair", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for IdentifierKeyValuePair
func (c *IdentifierKeyValuePair) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteObjectField("key")
	stream.WriteString(c.Key)
	stream.WriteMore()

	stream.WriteObjectField("value")
	stream.WriteString(c.Value)
	stream.WriteMore()

	stream.WriteObjectField("externalSubjectID")
	c.ExternalSubjectId.marshalJSON(stream)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Submodel
func (c *Submodel) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"qualifiers":         false,
		"extensions":         false,
		"id":                 false,
		"submodelElements":   false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "id":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Id = iter.ReadString()
			isThere["id"] = true
		case "administration":
			myobj := &AdministrativeInformation{}
			myobj.unmarshalJSON(iter)
			c.Administration = myobj
		case "submodelElements":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &SubmodelElement{}
				myobj.unmarshalJSON(iter)
				c.SubmodelElements = append(c.SubmodelElements, *myobj)
			}
			isThere["submodelElements"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object submodel", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Submodel
func (c *Submodel) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("kind")
	c.Kind.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("idShort")
	stream.WriteString(c.IdShort)
	stream.WriteMore()

	stream.WriteObjectField("displayName")
	c.DisplayName.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("category")
	stream.WriteString(c.Category)
	stream.WriteMore()

	stream.WriteObjectField("description")
	c.Description.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("id")
	stream.WriteString(c.Id)
	stream.WriteMore()

	stream.WriteObjectField("administration")
	c.Administration.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("submodelElements")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.SubmodelElements {
		k.marshalJSON(stream)
		if i < len(c.SubmodelElements)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for SubmodelElement
func (c *SubmodelElement) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object submodelElement", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for SubmodelElement
func (c *SubmodelElement) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("idShort")
	stream.WriteString(c.IdShort)
	stream.WriteMore()

	stream.WriteObjectField("displayName")
	c.DisplayName.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("category")
	stream.WriteString(c.Category)
	stream.WriteMore()

	stream.WriteObjectField("description")
	c.Description.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("kind")
	c.Kind.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for RelationshipElement
func (c *RelationshipElement) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"first":              false,
		"second":             false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "first":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			isThere["first"] = true
			c.First = myobj
		case "second":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			isThere["second"] = true
			c.Second = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object relationshipElement", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for RelationshipElement
func (c *RelationshipElement) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("idShort")
	stream.WriteString(c.IdShort)
	stream.WriteMore()

	stream.WriteObjectField("displayName")
	c.DisplayName.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("category")
	stream.WriteString(c.Category)
	stream.WriteMore()

	stream.WriteObjectField("description")
	c.Description.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("kind")
	c.Kind.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("first")
	c.First.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("second")
	c.Second.marshalJSON(stream)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for SubmodelElementList
func (c *SubmodelElementList) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications":        false,
		"extensions":                false,
		"qualifiers":                false,
		"submodelElementTypeValues": false,
		"values":                    false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "submodelElementTypeValues":
			var myenum SubmodelElements
			myenum.unmarshalJSON(iter)
			c.SubmodelElementTypeValues = &myenum
			isThere["submodelElementTypeValues"] = true
		case "values":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &SubmodelElement{}
				myobj.unmarshalJSON(iter)
				c.Values = append(c.Values, *myobj)
			}
			isThere["values"] = true
		case "semanticIDValues":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticIdValues = myobj
		case "valueTypeValues":
			var myenum DataTypeDef
			myenum.unmarshalJSON(iter)
			c.ValueTypeValues = &myenum
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object submodelElementList", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for SubmodelElementList
func (c *SubmodelElementList) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("idShort")
	stream.WriteString(c.IdShort)
	stream.WriteMore()

	stream.WriteObjectField("displayName")
	c.DisplayName.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("category")
	stream.WriteString(c.Category)
	stream.WriteMore()

	stream.WriteObjectField("description")
	c.Description.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("kind")
	c.Kind.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("submodelElementTypeValues")
	c.SubmodelElementTypeValues.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("values")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Values {
		k.marshalJSON(stream)
		if i < len(c.Values)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("semanticIDValues")
	c.SemanticIdValues.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("valueTypeValues")
	c.ValueTypeValues.marshalJSON(stream)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for SubmodelElementStruct
func (c *SubmodelElementStruct) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"values":             false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "values":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &SubmodelElement{}
				myobj.unmarshalJSON(iter)
				c.Values = append(c.Values, *myobj)
			}
			isThere["values"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object submodelElementStruct", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for SubmodelElementStruct
func (c *SubmodelElementStruct) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("idShort")
	stream.WriteString(c.IdShort)
	stream.WriteMore()

	stream.WriteObjectField("displayName")
	c.DisplayName.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("category")
	stream.WriteString(c.Category)
	stream.WriteMore()

	stream.WriteObjectField("description")
	c.Description.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("kind")
	c.Kind.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("values")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Values {
		k.marshalJSON(stream)
		if i < len(c.Values)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for DataElement
func (c *DataElement) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object dataElement", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for DataElement
func (c *DataElement) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("idShort")
	stream.WriteString(c.IdShort)
	stream.WriteMore()

	stream.WriteObjectField("displayName")
	c.DisplayName.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("category")
	stream.WriteString(c.Category)
	stream.WriteMore()

	stream.WriteObjectField("description")
	c.Description.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("kind")
	c.Kind.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Property
func (c *Property) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"valueType":          false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "valueType":
			var myenum DataTypeDef
			myenum.unmarshalJSON(iter)
			c.ValueType = &myenum
			isThere["valueType"] = true
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Value = iter.ReadString()
		case "valueID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.ValueId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object property", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Property
func (c *Property) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("idShort")
	stream.WriteString(c.IdShort)
	stream.WriteMore()

	stream.WriteObjectField("displayName")
	c.DisplayName.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("category")
	stream.WriteString(c.Category)
	stream.WriteMore()

	stream.WriteObjectField("description")
	c.Description.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("kind")
	c.Kind.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("valueType")
	c.ValueType.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("value")
	stream.WriteString(c.Value)
	stream.WriteMore()

	stream.WriteObjectField("valueID")
	c.ValueId.marshalJSON(stream)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for MultiLanguageProperty
func (c *MultiLanguageProperty) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "translatable":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Translatable = myobj
		case "valueID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.ValueId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object multiLanguageProperty", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for MultiLanguageProperty
func (c *MultiLanguageProperty) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("idShort")
	stream.WriteString(c.IdShort)
	stream.WriteMore()

	stream.WriteObjectField("displayName")
	c.DisplayName.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("category")
	stream.WriteString(c.Category)
	stream.WriteMore()

	stream.WriteObjectField("description")
	c.Description.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("kind")
	c.Kind.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("translatable")
	c.Translatable.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("valueID")
	c.ValueId.marshalJSON(stream)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Range
func (c *Range) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"valueType":          false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "valueType":
			var myenum DataTypeDef
			myenum.unmarshalJSON(iter)
			c.ValueType = &myenum
			isThere["valueType"] = true
		case "min":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Min = iter.ReadString()
		case "max":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Max = iter.ReadString()
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object range", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Range
func (c *Range) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("idShort")
	stream.WriteString(c.IdShort)
	stream.WriteMore()

	stream.WriteObjectField("displayName")
	c.DisplayName.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("category")
	stream.WriteString(c.Category)
	stream.WriteMore()

	stream.WriteObjectField("description")
	c.Description.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("kind")
	c.Kind.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("valueType")
	c.ValueType.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("min")
	stream.WriteString(c.Min)
	stream.WriteMore()

	stream.WriteObjectField("max")
	stream.WriteString(c.Max)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for ReferenceElement
func (c *ReferenceElement) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "reference":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.Reference = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object referenceElement", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for ReferenceElement
func (c *ReferenceElement) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("idShort")
	stream.WriteString(c.IdShort)
	stream.WriteMore()

	stream.WriteObjectField("displayName")
	c.DisplayName.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("category")
	stream.WriteString(c.Category)
	stream.WriteMore()

	stream.WriteObjectField("description")
	c.Description.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("kind")
	c.Kind.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("reference")
	c.Reference.marshalJSON(stream)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Blob
func (c *Blob) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"mimeType":           false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "mimeType":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.MimeType = iter.ReadString()
			isThere["mimeType"] = true
		case "content":
			if next := iter.WhatIsNext(); next != json.ArrayValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.ArrayValue, got: %s", next))
			}
			c.Content = iter.ReadString()
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object blob", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Blob
func (c *Blob) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("idShort")
	stream.WriteString(c.IdShort)
	stream.WriteMore()

	stream.WriteObjectField("displayName")
	c.DisplayName.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("category")
	stream.WriteString(c.Category)
	stream.WriteMore()

	stream.WriteObjectField("description")
	c.Description.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("kind")
	c.Kind.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("mimeType")
	stream.WriteString(c.MimeType)
	stream.WriteMore()

	stream.WriteObjectField("content")
	stream.WriteString(c.Content)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for File
func (c *File) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"mimeType":           false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "mimeType":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.MimeType = iter.ReadString()
			isThere["mimeType"] = true
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Value = iter.ReadString()
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object file", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for File
func (c *File) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("idShort")
	stream.WriteString(c.IdShort)
	stream.WriteMore()

	stream.WriteObjectField("displayName")
	c.DisplayName.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("category")
	stream.WriteString(c.Category)
	stream.WriteMore()

	stream.WriteObjectField("description")
	c.Description.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("kind")
	c.Kind.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("mimeType")
	stream.WriteString(c.MimeType)
	stream.WriteMore()

	stream.WriteObjectField("value")
	stream.WriteString(c.Value)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for AnnotatedRelationshipElement
func (c *AnnotatedRelationshipElement) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"first":              false,
		"second":             false,
		"annotation":         false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "first":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			isThere["first"] = true
			c.First = myobj
		case "second":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			isThere["second"] = true
			c.Second = myobj
		case "annotation":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &DataElement{}
				myobj.unmarshalJSON(iter)
				c.Annotation = append(c.Annotation, *myobj)
			}
			isThere["annotation"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object annotatedRelationshipElement", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for AnnotatedRelationshipElement
func (c *AnnotatedRelationshipElement) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("idShort")
	stream.WriteString(c.IdShort)
	stream.WriteMore()

	stream.WriteObjectField("displayName")
	c.DisplayName.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("category")
	stream.WriteString(c.Category)
	stream.WriteMore()

	stream.WriteObjectField("description")
	c.Description.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("kind")
	c.Kind.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("first")
	c.First.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("second")
	c.Second.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("annotation")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Annotation {
		k.marshalJSON(stream)
		if i < len(c.Annotation)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for EntityType
func (e EntityType) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := EntityType_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for EntityType
func (e EntityType) marshalJSON(stream *json.Stream) {
	stream.WriteString(EntityType_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for Entity
func (c *Entity) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"entityType":         false,
		"statements":         false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "entityType":
			var myenum EntityType
			myenum.unmarshalJSON(iter)
			c.EntityType = &myenum
			isThere["entityType"] = true
		case "statements":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &SubmodelElement{}
				myobj.unmarshalJSON(iter)
				c.Statements = append(c.Statements, *myobj)
			}
			isThere["statements"] = true
		case "globalAssetID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.GlobalAssetId = myobj
		case "specificAssetID":
			myobj := &IdentifierKeyValuePair{}
			myobj.unmarshalJSON(iter)
			c.SpecificAssetId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object entity", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Entity
func (c *Entity) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("idShort")
	stream.WriteString(c.IdShort)
	stream.WriteMore()

	stream.WriteObjectField("displayName")
	c.DisplayName.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("category")
	stream.WriteString(c.Category)
	stream.WriteMore()

	stream.WriteObjectField("description")
	c.Description.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("kind")
	c.Kind.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("entityType")
	c.EntityType.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("statements")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Statements {
		k.marshalJSON(stream)
		if i < len(c.Statements)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("globalAssetID")
	c.GlobalAssetId.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("specificAssetID")
	c.SpecificAssetId.marshalJSON(stream)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Event
func (c *Event) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object event", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Event
func (c *Event) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("idShort")
	stream.WriteString(c.IdShort)
	stream.WriteMore()

	stream.WriteObjectField("displayName")
	c.DisplayName.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("category")
	stream.WriteString(c.Category)
	stream.WriteMore()

	stream.WriteObjectField("description")
	c.Description.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("kind")
	c.Kind.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for BasicEvent
func (c *BasicEvent) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"observed":           false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "observed":
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object basicEvent", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for BasicEvent
func (c *BasicEvent) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("idShort")
	stream.WriteString(c.IdShort)
	stream.WriteMore()

	stream.WriteObjectField("displayName")
	c.DisplayName.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("category")
	stream.WriteString(c.Category)
	stream.WriteMore()

	stream.WriteObjectField("description")
	c.Description.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("kind")
	c.Kind.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("observed")

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Operation
func (c *Operation) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
		"inputVariables":     false,
		"outputVariables":    false,
		"inoutputVariables":  false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		case "inputVariables":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &OperationVariable{}
				myobj.unmarshalJSON(iter)
				c.InputVariables = append(c.InputVariables, *myobj)
			}
			isThere["inputVariables"] = true
		case "outputVariables":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &OperationVariable{}
				myobj.unmarshalJSON(iter)
				c.OutputVariables = append(c.OutputVariables, *myobj)
			}
			isThere["outputVariables"] = true
		case "inoutputVariables":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &OperationVariable{}
				myobj.unmarshalJSON(iter)
				c.InoutputVariables = append(c.InoutputVariables, *myobj)
			}
			isThere["inoutputVariables"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object operation", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Operation
func (c *Operation) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("idShort")
	stream.WriteString(c.IdShort)
	stream.WriteMore()

	stream.WriteObjectField("displayName")
	c.DisplayName.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("category")
	stream.WriteString(c.Category)
	stream.WriteMore()

	stream.WriteObjectField("description")
	c.Description.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("kind")
	c.Kind.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("inputVariables")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.InputVariables {
		k.marshalJSON(stream)
		if i < len(c.InputVariables)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("outputVariables")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.OutputVariables {
		k.marshalJSON(stream)
		if i < len(c.OutputVariables)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("inoutputVariables")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.InoutputVariables {
		k.marshalJSON(stream)
		if i < len(c.InoutputVariables)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for OperationVariable
func (c *OperationVariable) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"value": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "value":
			myobj := &SubmodelElement{}
			myobj.unmarshalJSON(iter)
			isThere["value"] = true
			c.Value = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object operationVariable", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for OperationVariable
func (c *OperationVariable) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("value")
	c.Value.marshalJSON(stream)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Capability
func (c *Capability) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"qualifiers":         false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "kind":
			var myenum ModelingKind
			myenum.unmarshalJSON(iter)
			c.Kind = &myenum
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "qualifiers":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Constraint{}
				myobj.unmarshalJSON(iter)
				c.Qualifiers = append(c.Qualifiers, *myobj)
			}
			isThere["qualifiers"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object capability", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Capability
func (c *Capability) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("idShort")
	stream.WriteString(c.IdShort)
	stream.WriteMore()

	stream.WriteObjectField("displayName")
	c.DisplayName.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("category")
	stream.WriteString(c.Category)
	stream.WriteMore()

	stream.WriteObjectField("description")
	c.Description.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("kind")
	c.Kind.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("qualifiers")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Qualifiers {
		k.marshalJSON(stream)
		if i < len(c.Qualifiers)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for ConceptDescription
func (c *ConceptDescription) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"id":                 false,
		"isCaseOf":           false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "id":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Id = iter.ReadString()
			isThere["id"] = true
		case "administration":
			myobj := &AdministrativeInformation{}
			myobj.unmarshalJSON(iter)
			c.Administration = myobj
		case "isCaseOf":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.IsCaseOf = append(c.IsCaseOf, *myobj)
			}
			isThere["isCaseOf"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object conceptDescription", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for ConceptDescription
func (c *ConceptDescription) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("idShort")
	stream.WriteString(c.IdShort)
	stream.WriteMore()

	stream.WriteObjectField("displayName")
	c.DisplayName.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("category")
	stream.WriteString(c.Category)
	stream.WriteMore()

	stream.WriteObjectField("description")
	c.Description.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("id")
	stream.WriteString(c.Id)
	stream.WriteMore()

	stream.WriteObjectField("administration")
	c.Administration.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("isCaseOf")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.IsCaseOf {
		k.marshalJSON(stream)
		if i < len(c.IsCaseOf)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for View
func (c *View) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"dataSpecifications": false,
		"extensions":         false,
		"containedElements":  false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "dataSpecifications":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Reference{}
				myobj.unmarshalJSON(iter)
				c.DataSpecifications = append(c.DataSpecifications, *myobj)
			}
			isThere["dataSpecifications"] = true
		case "extensions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Extension{}
				myobj.unmarshalJSON(iter)
				c.Extensions = append(c.Extensions, *myobj)
			}
			isThere["extensions"] = true
		case "idShort":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.IdShort = iter.ReadString()
		case "displayName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.DisplayName = myobj
		case "category":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Category = iter.ReadString()
		case "description":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Description = myobj
		case "semanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.SemanticId = myobj
		case "containedElements":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
			}
			isThere["containedElements"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object view", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for View
func (c *View) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("dataSpecifications")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.DataSpecifications {
		k.marshalJSON(stream)
		if i < len(c.DataSpecifications)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("extensions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Extensions {
		k.marshalJSON(stream)
		if i < len(c.Extensions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("idShort")
	stream.WriteString(c.IdShort)
	stream.WriteMore()

	stream.WriteObjectField("displayName")
	c.DisplayName.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("category")
	stream.WriteString(c.Category)
	stream.WriteMore()

	stream.WriteObjectField("description")
	c.Description.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("semanticID")
	c.SemanticId.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("containedElements")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.ContainedElements {
		k.marshalJSON(stream)
		if i < len(c.ContainedElements)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Reference
func (c *Reference) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object reference", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Reference
func (c *Reference) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for GlobalReference
func (c *GlobalReference) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"values": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "values":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				if next := iter.WhatIsNext(); next != json.StringValue {
					iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
				}
				c.Values = iter.ReadString()
			}
			isThere["values"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object globalReference", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for GlobalReference
func (c *GlobalReference) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("values")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Values {
		k.marshalJSON(stream)
		if i < len(c.Values)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for ModelReference
func (c *ModelReference) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"keys": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "keys":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Key{}
				myobj.unmarshalJSON(iter)
				c.Keys = append(c.Keys, *myobj)
			}
			isThere["keys"] = true
		case "referredSemanticID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.ReferredSemanticId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object modelReference", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for ModelReference
func (c *ModelReference) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("keys")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Keys {
		k.marshalJSON(stream)
		if i < len(c.Keys)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("referredSemanticID")
	c.ReferredSemanticId.marshalJSON(stream)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Key
func (c *Key) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"type":  false,
		"value": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "type":
			var myenum KeyElements
			myenum.unmarshalJSON(iter)
			c.Type = &myenum
			isThere["type"] = true
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Value = iter.ReadString()
			isThere["value"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object key", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Key
func (c *Key) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("type")
	c.Type.marshalJSON(stream)
	stream.WriteObjectField("value")
	stream.WriteString(c.Value)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for IdentifiableElements
func (e IdentifiableElements) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := IdentifiableElements_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for IdentifiableElements
func (e IdentifiableElements) marshalJSON(stream *json.Stream) {
	stream.WriteString(IdentifiableElements_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for ReferableElements
func (e ReferableElements) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := ReferableElements_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for ReferableElements
func (e ReferableElements) marshalJSON(stream *json.Stream) {
	stream.WriteString(ReferableElements_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for KeyElements
func (e KeyElements) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := KeyElements_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for KeyElements
func (e KeyElements) marshalJSON(stream *json.Stream) {
	stream.WriteString(KeyElements_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for SubmodelElements
func (e SubmodelElements) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := SubmodelElements_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for SubmodelElements
func (e SubmodelElements) marshalJSON(stream *json.Stream) {
	stream.WriteString(SubmodelElements_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for BuildInListTypes
func (e BuildInListTypes) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := BuildInListTypes_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for BuildInListTypes
func (e BuildInListTypes) marshalJSON(stream *json.Stream) {
	stream.WriteString(BuildInListTypes_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for DecimalBuildInTypes
func (e DecimalBuildInTypes) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := DecimalBuildInTypes_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for DecimalBuildInTypes
func (e DecimalBuildInTypes) marshalJSON(stream *json.Stream) {
	stream.WriteString(DecimalBuildInTypes_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for DurationBuildInTypes
func (e DurationBuildInTypes) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := DurationBuildInTypes_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for DurationBuildInTypes
func (e DurationBuildInTypes) marshalJSON(stream *json.Stream) {
	stream.WriteString(DurationBuildInTypes_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for PrimitiveTypes
func (e PrimitiveTypes) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := PrimitiveTypes_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for PrimitiveTypes
func (e PrimitiveTypes) marshalJSON(stream *json.Stream) {
	stream.WriteString(PrimitiveTypes_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for StringBuildInTypes
func (e StringBuildInTypes) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := StringBuildInTypes_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for StringBuildInTypes
func (e StringBuildInTypes) marshalJSON(stream *json.Stream) {
	stream.WriteString(StringBuildInTypes_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for DataTypeDef
func (e DataTypeDef) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := DataTypeDef_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for DataTypeDef
func (e DataTypeDef) marshalJSON(stream *json.Stream) {
	stream.WriteString(DataTypeDef_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for LangStringSet
func (c *LangStringSet) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object langStringSet", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for LangStringSet
func (c *LangStringSet) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for DataSpecificationContent
func (c *DataSpecificationContent) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object dataSpecificationContent", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for DataSpecificationContent
func (c *DataSpecificationContent) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for DataTypeIec61360
func (e DataTypeIec61360) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := DataTypeIec61360_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for DataTypeIec61360
func (e DataTypeIec61360) marshalJSON(stream *json.Stream) {
	stream.WriteString(DataTypeIec61360_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for LevelType
func (e LevelType) unmarshalJSON(iter *json.Iterator) {
	raw := iter.ReadString()
	if v, ok := LevelType_value[raw]; !ok {
		iter.ReportError("unknown-enum-value", fmt.Sprintf("%s is not a valid enum value", raw))
	} else {
		e = v
	}
}

// marshalJSON implements the Marshaler interface for LevelType
func (e LevelType) marshalJSON(stream *json.Stream) {
	stream.WriteString(LevelType_name[e])
}

// unmarshalJSON implements the Unmarshaler interface for ValueReferencePair
func (c *ValueReferencePair) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"value":   false,
		"valueID": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Value = iter.ReadString()
			isThere["value"] = true
		case "valueID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			isThere["valueID"] = true
			c.ValueId = myobj
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object valueReferencePair", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for ValueReferencePair
func (c *ValueReferencePair) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("value")
	stream.WriteString(c.Value)
	stream.WriteObjectField("valueID")
	c.ValueId.marshalJSON(stream)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for ValueList
func (c *ValueList) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"valueReferencePairs": false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "valueReferencePairs":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ValueReferencePair{}
				myobj.unmarshalJSON(iter)
				c.ValueReferencePairs = append(c.ValueReferencePairs, *myobj)
			}
			isThere["valueReferencePairs"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object valueList", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for ValueList
func (c *ValueList) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("valueReferencePairs")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.ValueReferencePairs {
		k.marshalJSON(stream)
		if i < len(c.ValueReferencePairs)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for DataSpecificationIec61360
func (c *DataSpecificationIec61360) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "preferredName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.PreferredName = myobj
		case "shortName":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.ShortName = myobj
		case "unit":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Unit = iter.ReadString()
		case "unitID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.UnitId = myobj
		case "sourceOfDefinition":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.SourceOfDefinition = iter.ReadString()
		case "symbol":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Symbol = iter.ReadString()
		case "dataType":
			var myenum DataTypeIec61360
			myenum.unmarshalJSON(iter)
			c.DataType = &myenum
		case "definition":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Definition = myobj
		case "valueFormat":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.ValueFormat = iter.ReadString()
		case "valueList":
			myobj := &ValueList{}
			myobj.unmarshalJSON(iter)
			c.ValueList = myobj
		case "value":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Value = iter.ReadString()
		case "valueID":
			myobj := &Reference{}
			myobj.unmarshalJSON(iter)
			c.ValueId = myobj
		case "levelType":
			var myenum LevelType
			myenum.unmarshalJSON(iter)
			c.LevelType = &myenum
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object dataSpecificationIec61360", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for DataSpecificationIec61360
func (c *DataSpecificationIec61360) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("preferredName")
	c.PreferredName.marshalJSON(stream)
	stream.WriteObjectField("shortName")
	c.ShortName.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("unit")
	stream.WriteString(c.Unit)
	stream.WriteMore()

	stream.WriteObjectField("unitID")
	c.UnitId.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("sourceOfDefinition")
	stream.WriteString(c.SourceOfDefinition)
	stream.WriteMore()

	stream.WriteObjectField("symbol")
	stream.WriteString(c.Symbol)
	stream.WriteMore()

	stream.WriteObjectField("dataType")
	c.DataType.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("definition")
	c.Definition.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("valueFormat")
	stream.WriteString(c.ValueFormat)
	stream.WriteMore()

	stream.WriteObjectField("valueList")
	c.ValueList.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("value")
	stream.WriteString(c.Value)
	stream.WriteMore()

	stream.WriteObjectField("valueID")
	c.ValueId.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("levelType")
	c.LevelType.marshalJSON(stream)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for DataSpecificationPhysicalUnit
func (c *DataSpecificationPhysicalUnit) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "unitName":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.UnitName = iter.ReadString()
		case "unitSymbol":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.UnitSymbol = iter.ReadString()
		case "definition":
			myobj := &LangStringSet{}
			myobj.unmarshalJSON(iter)
			c.Definition = myobj
		case "siNotation":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.SiNotation = iter.ReadString()
		case "dinNotation":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.DinNotation = iter.ReadString()
		case "eceName":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.EceName = iter.ReadString()
		case "eceCode":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.EceCode = iter.ReadString()
		case "nistName":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.NistName = iter.ReadString()
		case "sourceOfDefinition":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.SourceOfDefinition = iter.ReadString()
		case "conversionFactor":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.ConversionFactor = iter.ReadString()
		case "registrationAuthorityID":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.RegistrationAuthorityId = iter.ReadString()
		case "supplier":
			if next := iter.WhatIsNext(); next != json.StringValue {
				iter.ReportError("unexpected-json-type", fmt.Sprintf("expected json.StringValue, got: %s", next))
			}
			c.Supplier = iter.ReadString()
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object dataSpecificationPhysicalUnit", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for DataSpecificationPhysicalUnit
func (c *DataSpecificationPhysicalUnit) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("unitName")
	stream.WriteString(c.UnitName)
	stream.WriteObjectField("unitSymbol")
	stream.WriteString(c.UnitSymbol)
	stream.WriteMore()

	stream.WriteObjectField("definition")
	c.Definition.marshalJSON(stream)
	stream.WriteMore()

	stream.WriteObjectField("siNotation")
	stream.WriteString(c.SiNotation)
	stream.WriteMore()

	stream.WriteObjectField("dinNotation")
	stream.WriteString(c.DinNotation)
	stream.WriteMore()

	stream.WriteObjectField("eceName")
	stream.WriteString(c.EceName)
	stream.WriteMore()

	stream.WriteObjectField("eceCode")
	stream.WriteString(c.EceCode)
	stream.WriteMore()

	stream.WriteObjectField("nistName")
	stream.WriteString(c.NistName)
	stream.WriteMore()

	stream.WriteObjectField("sourceOfDefinition")
	stream.WriteString(c.SourceOfDefinition)
	stream.WriteMore()

	stream.WriteObjectField("conversionFactor")
	stream.WriteString(c.ConversionFactor)
	stream.WriteMore()

	stream.WriteObjectField("registrationAuthorityID")
	stream.WriteString(c.RegistrationAuthorityId)
	stream.WriteMore()

	stream.WriteObjectField("supplier")
	stream.WriteString(c.Supplier)

	stream.WriteObjectEnd()
}

// unmarshalJSON implements the Unmarshaler interface for Environment
func (c *Environment) unmarshalJSON(iter *json.Iterator) {
	isThere := map[string]bool{
		"assetAdministrationShells": false,
		"submodels":                 false,
		"conceptDescriptions":       false,
	}
	// iterate through all provided object properties and switch on property name
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {
		case "assetAdministrationShells":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &AssetAdministrationShell{}
				myobj.unmarshalJSON(iter)
				c.AssetAdministrationShells = append(c.AssetAdministrationShells, *myobj)
			}
			isThere["assetAdministrationShells"] = true
		case "submodels":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &Submodel{}
				myobj.unmarshalJSON(iter)
				c.Submodels = append(c.Submodels, *myobj)
			}
			isThere["submodels"] = true
		case "conceptDescriptions":
			// loop through every element in the array and unmarshal it
			for el := iter.ReadArray(); el; el = iter.ReadArray() {
				myobj := &ConceptDescription{}
				myobj.unmarshalJSON(iter)
				c.ConceptDescriptions = append(c.ConceptDescriptions, *myobj)
			}
			isThere["conceptDescriptions"] = true
		default:
			iter.ReportError("unknown-property", fmt.Sprintf("%s is not a valid property in object environment", f))
		}
	}
	for k, v := range isThere {
		if !v {
			iter.ReportError("Required property is missing", fmt.Sprintf("%s", k))
			break
		}
	}
}

// marshalJSON implements Marshaler interface for Environment
func (c *Environment) marshalJSON(stream *json.Stream) {
	stream.WriteObjectStart()

	stream.WriteObjectField("assetAdministrationShells")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.AssetAdministrationShells {
		k.marshalJSON(stream)
		if i < len(c.AssetAdministrationShells)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteObjectField("submodels")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.Submodels {
		k.marshalJSON(stream)
		if i < len(c.Submodels)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()
	stream.WriteMore()

	stream.WriteObjectField("conceptDescriptions")
	// loop through every element in the slice and write it to the stream
	stream.WriteArrayStart()
	for i, k := range c.ConceptDescriptions {
		k.marshalJSON(stream)
		if i < len(c.ConceptDescriptions)-1 {
			stream.WriteMore()
		}
	}
	stream.WriteArrayEnd()

	stream.WriteObjectEnd()
}
